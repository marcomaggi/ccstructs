\input texinfo.tex
@c %**start of header
@setfilename ccstructs.info
@settitle CCStructs
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCStructs

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCStructs

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccstructs

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2018, 2019, 2020

@c ------------------------------------------------------------

@set CCExceptionsVersion       0.10.0
@set CCMemoryVersion           0.3.0
@set CCTestsVersion            0.5.0

@c ------------------------------------------------------------------------

@set PackageAutoconfPrefix              CCSTRUCTS
@set PackagePkgconfigModule             ccstructs
@set PackageLibsVar                     @env{CCSTRUCTS_LIBS}
@set PackageCflagsVar                   @env{CCSTRUCTS_CFLAGS}
@c This is the stem of the library in "libccstructs.so".
@set PackageLibstem                     ccstructs
@set PackageApiPrefixLower              ccstructs_
@set PackageApiPrefixUpper              CCSTRUCTS_

@set PackageHeader                      ccstructs.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing common programming traits for C data structures.

This package supports @posix{} platforms.  This package depends on the external packages:
CCExceptions, at least version @value{CCExceptionsVersion}; CCMemory, at least version
@value{CCMemoryVersion}.  To run the test suite: this package depends upon the external package
CCTests, at least version @value{CCTestsVersion}.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccstructs: (ccstructs).       Common traits for C structs.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* core::                        Core type definitions.
* dtor::                        The @trait{dtor} trait.
* dumpable::                    The @trait{dumpable} trait.
* serialiser::                  The @trait{serialiser} trait.
* deserialiser::                The @trait{deserialiser} trait.
* pathname::                    The @trait{pathname} trait.
* utils::                       Utility definitions.

Appendices

* ccnames::                     Automatically generated @api{} names.
* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing common programming traits for C data structures.

This package supports @posix{} platforms.  This package depends on the packages: CCExceptions, at
least version @value{CCExceptionsVersion}; CCMemory, at least version @value{CCMemoryVersion}.  To
run the test suite: this package depends upon the package CCTests, at least version
@value{CCTestsVersion}.

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs the single header file @value{PackageHeaderFile}.  All the function names
in the @api{} are prefixed with @code{@value{PackageApiPrefixLower}}; all the preprocessor symbol
names are prefixed with @code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

In addition the package installs the header file @file{ccnames.h}; in this file: all the macro names
are prefixed with @code{ccname_}; all the preprocessor symbol names are prefixed with
@code{CCNAME_}.

@menu
* overview linking::            Linking code with the library.
* overview ccnames::            Generated function names.
* overview exceptions::         Handling exceptional conditions.
* overview allocation::         Memory allocation for pathname instances.
* overview examples::           Implementation examples.
@end menu

@include overview-linking.texi
@include overview-ccnames.texi
@include overview-ccexceptions.texi
@include overview-ccmemory.texi

@c page
@node overview examples
@section Implementation examples


The source distribution comes with some implementation examples under the directory @file{examples}.
That code is meant to be a starting point when implementing the traits defined by
@value{PACKAGE}: we should copy it and adapt it to our needs.  Really!

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccstructs_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int ccstructs_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccstructs_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int ccstructs_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node core
@chapter Core type definitions


@value{PACKAGE} offers an @api{} to handle @struct{} values.  The library cannot reference the
concrete types of @struct{} the client libraries will use, so it just defines a placeholder for
them.


@deftp {Struct Typedef} ccstructs_core_t
Type of @struct{} values used as argument to @value{PACKAGE} functions.  This is just a forward type
declaration: there is no actual declaration of this type.
@end deftp


When using this type we need to explicitly cast a pointer to client @struct{} values to a pointer to
@objtype{ccstruct_core_t}.  For example, when defining a constructor for the @trait{dumpable} trait:

@example
ccstructs_dumpable_T
ccname_trait_new(ccstructs_dumpable_T, spiffy_t) (spiffy_t * S)
@{
  return ccname_new(ccstructs_dumpable_T)(ccstructs_core(S),
    &ccname_trait_table(ccstructs_dumpable_T, spiffy_t));
@}
@end example


@deftypefun {ccstructs_core_t const *} ccstructs_core (void const * @var{S})
Cast the pointer @var{S} to @code{ccstructs_core_t *}.
@end deftypefun


@deftypefn {Function Prototype} void ccstructs_core_destructor_fun_t (ccstructs_core_t * @var{self})
Type of functions implementing the destructor for @struct{} instances.  Functions of this type must
always return to their caller, never raising an exception.
@end deftypefn

@c page
@node dtor
@chapter The @trait{dtor} trait


The @trait{dtor} trait provides a uniform way to call the destructors of a @struct{} type.  The best
way to use the @trait{dtor} trait is through the exception handlers @api{}, @ref{dtor handlers,
Exception handlers}.

@menu
* dtor typedefs::               @trait{dtor} trait: type definitions.
* dtor operations::             @trait{dtor} trait: operations.
* dtor handlers::               Exception handlers.
@end menu

@c page
@node dtor typedefs
@section @trait{dtor} trait: type definitions


@deftp {Struct Typedef} ccstructs_dtor_T
Type of the @trait{dtor} trait @struct{}.  Instances of this type are meant to be handed by value to
function calls.
@end deftp

@c page
@node dtor operations
@section @trait{dtor} trait: operations


@deftypefun ccstructs_dtor_T {ccname_new(ccstructs_dtor_T)} (ccstructs_core_t const * @var{S}, ccstructs_core_destructor_fun_t * @var{destructor})
Build and return a new @trait{dtor} trait instance as implemented for the @struct{} type of @var{S}.
@var{destroy} must be a pointer to the destructor function.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_dtor_self (ccstructs_dtor_T @var{I})
Return a pointer to the subject @struct{} to which the trait belongs.
@end deftypefun


@deftypefun void ccstructs_dtor_destroy (ccstructs_dtor_T @var{I})
Destroy the referenced @struct{} instance using the referenced destructor function.
@end deftypefun

@c page
@node dtor handlers
@section Exception handlers


The best way to use the @trait{dtor} trait is through the exception handlers @api{}.


@deftp {Struct Typedef} ccstructs_clean_handler_t
Type of @struct{} usable has clean handler with the facilities of the CCExceptions library.
@end deftp


@deftp {Struct Typedef} ccstructs_error_handler_t
Type of @struct{} usable has error handler with the facilities of the CCExceptions library.
@end deftp


@deftypefun void ccstructs_init_and_register_clean_handler (cce_destination_t @var{L}, ccstructs_clean_handler_t * @var{H}, ccstructs_dtor_T @var{I})
Initialise the exception handler @var{H} to apply the destructor to a @struct{} instance as defined
by @var{I}, in the context of the location @var{L}.
@end deftypefun


@deftypefun void ccstructs_init_and_register_error_handler (cce_destination_t @var{L}, ccstructs_error_handler_t * @var{H}, ccstructs_dtor_T @var{I})
Initialise the exception handler @var{H} to apply the destructor to a @struct{} instance as defined
by @var{I}, in the context of the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccstructs_init_and_register_handler (cce_destination_t @var{L}, @var{H}, ccstructs_dtor_T @var{I})
Initialise the exception handler @var{H} to apply the destructor to a @struct{} instance as defined
by @var{I}, in the context of the location @var{L}.  If @var{H} is a pointer of type:

@table @code
@item ccstructs_clean_handler_t
The macro use expands into a call to @cfunc{ccstructs_init_and_register_clean_handler}.

@item ccstructs_error_handler_t
The macro use expands into a call to @cfunc{ccstructs_init_and_register_error_handler}.
@end table
@end deftypefn

@c page
@node dumpable
@chapter The @trait{dumpable} trait


The @trait{dumpable} trait, represented by the type @objtype{ccstructs_dumpable_T}, is meant to
write an object to some output channel, mostly for inspection and debugging purposes; this trait
is neither for presentation to the end user of a program, nor for memorisation on a storage device.

@menu
* dumpable typedefs::           @trait{dumpable} trait: type definitions.
* dumpable operations::         @trait{dumpable} trait: operations.
* dumpable sample::             Example of @trait{dumpable} trait
                                implementation
@end menu

@c page
@node dumpable typedefs
@section @trait{dumpable} trait: type definitions


@deftp {Struct Typedef} ccstructs_dumpable_T
Type of the @trait{dumpable} trait.  Instances of this type are meant to be handed by value to
function calls.
@end deftp


@deftp {Struct Typedef} {ccname_trait_table_type(ccstructs_dumpable_T)}
Type of methods table for the @trait{dumpable} trait.  It has the following fields:

@table @code
@item ccname_trait_method_type(ccstructs_dumpable_T, dump) * dump
Pointer to function implementing the @method{dump} method.
@end table
@end deftp


@deftypefn {Function Prototype} void {ccname_trait_method_type(ccstructs_dumpable_T, dump)} (cce_destination_t @var{L}, ccstructs_dumpable_T @var{I})
Type of functions implementing the @method{dump} method.  Functions of this type write a
representation of the object to an output channel (for example @stderr{}); it is responsibility of
this method to select which output channel to use.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefn

@c page
@node dumpable operations
@section @trait{dumpable} trait: operations


@deftypefun ccstructs_dumpable_T {ccname_new(ccstructs_dumpable_T)} (ccstructs_core_t const * @var{S}, ccname_trait_table_type(ccstructs_dumpable_T) const * @var{M})
Trait constructor.  Return a new trait @struct{} given a pointer to the source @struct{} and
a pointer to the trait methods.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_dumpable_self (ccstructs_dumpable_T @var{I})
Return a pointer to the @struct{} to which the trait belongs.
@end deftypefun


@deftypefun void ccstructs_dumpable_dump (cce_destination_t @var{L}, ccstructs_dumpable_T @var{I})
Apply the method @method{dump} to the @struct{}.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node dumpable sample
@section Example of @trait{dumpable} trait implementation


Let's say we have this @struct{} definition:

@example
typedef struct spiffy_t        spiffy_t;

struct spiffy_t @{
  int   alpha;
  int   beta;
@};
@end example

@noindent
we can implement a @trait{dumpable} trait as follows:

@smallexample
static void
ccname_trait_method(ccstructs_dumpable_T, spiffy_t, dump)
  (cce_destination_t L, ccstructs_dumpable_T I)
@{
  CCSTRUCTS_PC(spiffy_t, S, I.self);
  int   rv;

  errno = 0;
  rv = fprintf(stderr, "spiffy_t: alpha=%d, beta=%d\n", S->alpha, S->beta);
  if (0 > rv) @{
    cce_raise(L, cce_condition_new_errno_clear());
  @}
@}

static ccname_trait_table_type(ccstructs_dumpable_T) const
    ccname_trait_table(ccstructs_dumpable_T, spiffy_t) = @{
  .dump = ccname_trait_method(ccstructs_dumpable_T, spiffy_t, dump)
@};

ccstructs_dumpable_T
ccname_trait_new(ccstructs_dumpable_T, spiffy_t) (spiffy_t * S)
@{
  return ccname_trait_new(ccstructs_dumpable_T)(ccstructs_core(S),
    &ccname_trait_table(ccstructs_dumpable_T, spiffy_t));
@}
@end smallexample

@noindent
then we can use the trait as follows:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  spiffy_t   S = @{
    .alpha    = 1,
    .beta     = 2
  @};
  ccstructs_dumpable_T  I = ccname_trait_new(ccstructs_dumpable_T, spiffy_t)(&S);

  ccstructs_dumpable_dump(L, I);
  cce_run_body_handlers(L);
@}
@end smallexample

@c page
@node serialiser
@chapter The @trait{serialiser} trait


The @trait{serialiser} trait, represented by the type @objtype{ccstructs_serialiser_T}, allows
us to serialise a @struct{} into a destination storage.  The use of this trait is suggested to
serialise ``small'' data structures that can be written to storage with a single operation (that is:
it may be @strong{not} good if the serialisation is an @acronym{XML} document gigabytes in size).

For implementation examples we should look in the source distribution of @value{PACKAGE}.

@menu
* serialiser typedefs::         @trait{serialiser} trait: type definitions.
* serialiser operations::       @trait{serialiser} trait: operations.
@end menu

@c page
@node serialiser typedefs
@section @trait{serialiser} trait: type definitions


@deftp {Struct Typedef} ccstructs_serialiser_T
Type of the @trait{serialiser} trait.  Instances of this type are meant to be handed by value
to function calls.
@end deftp


@deftp {Struct Typedef} {ccname_trait_table_type(ccstructs_serialiser_T)}
Type of methods table for the @trait{serialiser} trait.  It has the following fields:

@table @code
@item ccname_trait_method_type(ccstructs_serialiser_T, required_size) * required_size
Pointer to function implementing the @method{required_size} method.

@item ccname_trait_method_type(ccstructs_serialiser_T, write) * write
Pointer to function implementing the @method{write} method.
@end table
@end deftp


@deftypefn {Function Prototype} size_t {ccname_trait_method_type(ccstructs_serialiser_T, required_size)} (ccstructs_serialiser_T const @var{I})
Type of functions implementing the @method{required_size} method.  Return the minimum number of
bytes needed to hold the serialisation of the source @struct{}; we should use the returned number to
allocate a block of memory for the serialisation operation; it is possible that the actual
serialisation will consume less memory.
@end deftypefn


@deftypefn {Function Prototype} ccmem_block_t {ccname_trait_method_type(ccstructs_serialiser_T, write)} (cce_destination_t @var{L}, ccstructs_serialiser_T const @var{I}, ccmem_block_t @var{B})
Type of functions implementing the @method{write} method.  Serialise the @struct{} to the block of
memory referenced by @var{B}, which must be big enough to hold the number of bytes returned by the
method @method{required_size}.

When successful: return a new block referencing the leftover memory right after the serialised data.
If an error occurs: raise an exception violation by performing a non--local exit to @var{L}; in this
case there is no way to know the state of the data written on the output block @var{B}.

@example
     memory block described by @var{B}
|-------------------------------------|
|++++++++++++++++++++++++|------------|
   memory filled with       leftover
   struct serialisation     memory
@end example
@end deftypefn

@c page
@node serialiser operations
@section @trait{serialiser} trait: operations


@deftypefun ccstructs_serialiser_T {ccname_new(ccstructs_serialiser_T)} (ccstructs_core_t const * @var{S}, ccname_trait_table_type(ccstructs_serialiser_T) const * @var{M})
Trait constructor.  Return a new trait @struct{} given a pointer to the source @struct{} and
a pointer to the trait methods.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_serialiser_self (ccstructs_serialiser_T @var{I})
Return a pointer to the @struct{} to which the trait belongs.
@end deftypefun


@deftypefun size_t ccstructs_serialiser_required_size (ccstructs_serialiser_T @var{I})
Apply the method @method{required_size} to the given argument.
@end deftypefun


@deftypefun ccmem_block_t ccstructs_serialiser_write (cce_destination_t @var{L}, ccstructs_serialiser_T @var{I}, ccmem_block_t @var{B})
Apply the method @method{write} to the given arguments.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node deserialiser
@chapter The @trait{deserialiser} trait


The @trait{deserialiser} trait, represented by the type @objtype{ccstructs_deserialiser_T},
allows us to deserialise a @struct{} from a source storage.  The use of this trait is suggested
to deserialise ``small'' data structures that can be read from storage with a single operation (that
is: it may be @strong{not} good if the serialisation is an @acronym{XML} document gigabytes in
size).

For implementation examples we should look in the source distribution of @value{PACKAGE}.

@menu
* deserialiser typedefs::       @trait{deserialiser} trait: type definitions.
* deserialiser operations::     @trait{deserialiser} trait: operations.
@end menu

@c page
@node deserialiser typedefs
@section @trait{deserialiser} trait: type definitions


@deftp {Struct Typedef} ccstructs_deserialiser_T
Type of the @trait{deserialiser} trait.  Instances of this type are meant to be handed by value
to function calls.
@end deftp


@deftp {Struct Typedef} {ccname_trait_table_type(ccstructs_deserialiser_T)}
Type of methods table for the @trait{deserialiser} trait.  It has the following fields:

@table @code
@item ccname_trait_method_type(ccstructs_deserialiser_T, required_size) * required_size
Pointer to function implementing the @method{required_size} method.

@item ccname_trait_method_type(ccstructs_deserialiser_T, read) * read
Pointer to function implementing the @method{read} method.
@end table
@end deftp


@deftypefn {Function Prototype} size_t {ccname_trait_method_type(ccstructs_deserialiser_T, required_size)} (ccstructs_deserialiser_T const @var{I})
Type of functions implementing the @method{required_size} method.  Return the minimum number of
bytes needed to hold the serialisation of the source @struct{}; it is possible that the actual
serialisation has consumed less memory.

Example: let's say we must read the serialised @struct{} from a file, how many bytes do we need to
read from the file to be sure to have it all?  This function answers this question.
@end deftypefn


@deftypefn {Function Prototype} ccmem_block_t {ccname_trait_method_type(ccstructs_deserialiser_T, read)} (cce_destination_t @var{L}, ccstructs_deserialiser_T const @var{I}, ccmem_block_t @var{B})
Type of functions implementing the @method{read} method. Deserialise the @struct{} from the block of
memory referenced by @var{B}, which must be big enough to hold the number of bytes returned by the
method @method{required_size}.  Return a new block referencing the memory right after the
deserialised data.  If an error occurs: raise an exception violation by performing a non--local exit
to @var{L}.
@end deftypefn

@c page
@node deserialiser operations
@section @trait{deserialiser} trait: operations


@deftypefun ccstructs_deserialiser_T {ccname_new(ccstructs_deserialiser_T)} (ccstructs_core_t const * @var{S}, ccname_trait_table_type(ccstructs_deserialiser_T) const * @var{M})
Trait constructor.  Return a new trait @struct{} given a pointer to the source @struct{} and
a pointer to the trait methods.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_deserialiser_self (ccstructs_deserialiser_T @var{I})
Return a pointer to the @struct{} to which the trait belongs.
@end deftypefun


@deftypefun size_t ccstructs_deserialiser_required_size (ccstructs_deserialiser_T @var{I})
Apply the method @method{required_size} to the given argument.
@end deftypefun


@deftypefun ccmem_block_t ccstructs_deserialiser_read (cce_destination_t @var{L}, ccstructs_deserialiser_T @var{I}, ccmem_block_t @var{B})
Apply the method @method{read} to the given arguments.  If an error occurs: raise an exception
by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node pathname
@chapter The @trait{pathname} trait


The @trait{pathname} trait, represented by the type @objtype{ccstructs_pathname_T}, is meant to
be used in algorithms that need to operate on @posix{} pathname specifications without being tied to
a specific pathname internal representation.

@menu
* pathname typedefs::           Type definitions.
* pathname api::                Programming trait.
* pathname simple::             Simple implementations.
@end menu

@c page
@node pathname typedefs
@section Type definitions for the @trait{pathname} trait


@deftp {Struct Typedef} ccstructs_pathname_T
Type of the @trait{pathname} trait.  Instances of this type are meant to be handed by value to
function calls.
@end deftp


@deftp {Struct Typedef} ccstructs_pathname_T_methods_t
Type of methods table for the @trait{pathname} trait.  It has the following fields:

@table @code
@item ccname_trait_method_type(ccstructs_pathname_T, asciiz) * asciiz
Pointer to function implementing the @method{asciiz} method.

@item ccname_trait_method_type(ccstructs_pathname_T, is_static) * is_static
Pointer to function implementing the @method{is_static} method.

@item ccname_trait_method_type(ccstructs_pathname_T, is_absolute) * is_absolute
Pointer to function implementing the @method{is_absolute} method.

@item ccname_trait_method_type(ccstructs_pathname_T, is_relative) * is_relative
Pointer to function implementing the @method{is_relative} method.

@item ccname_trait_method_type(ccstructs_pathname_T, is_normalised) * is_normalised
Pointer to function implementing the @method{is_normalised} method.

@item ccname_trait_method_type(ccstructs_pathname_T, is_realpath) * is_realpath
Pointer to function implementing the @method{is_realpath} method.

@item ccname_trait_method_type(ccstructs_pathname_T, dtor) * dtor
Pointer to function implementing the @method{dtor} method.

@item ccname_trait_method_type(ccstructs_pathname_T, dumpable) * dumpable
Pointer to function implementing the @method{dumpable} method.

@item ccname_trait_method_type(ccstructs_pathname_T, serialiser) * serialiser
Pointer to function implementing the @method{serialiser} method.

@item ccname_trait_method_type(ccstructs_pathname_T, deserialiser) * deserialiser
Pointer to function implementing the @method{deserialiser} method.
@end table
@end deftp


@deftypefn {Function Prototype} ccmem_asciiz_t {ccname_trait_method_type(ccstructs_pathname_T, asciiz)} (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Type of functions implementing the @method{asciiz} method.  Return an instance of
@objtype{ccmem_asciiz_t} holding an @asciiz{} representation of the pathname.  If an error occurs
generating the representation: raise an exception by performing a non--local exit to @var{L}.
@end deftypefn


@deftypefn {Function Prototype} bool {ccname_trait_method_type(ccstructs_pathname_T, is_static)} (ccstructs_pathname_T @var{I})
Type of functions implementing the @method{is_static} method.  In general, the user of @var{I}
should make a copy of the @asciiz{} pathname representation, returned by the @method{asciiz} method,
if it needs to keep it independently from the extent (the lifetime) of @var{I}; but if this function
returns @ctrue{}: it can rely on the existence of the representation for the time it needs it.
@end deftypefn


@deftypefn {Function Prototype} bool {ccname_trait_method_type(ccstructs_pathname_T, is_absolute)} (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Type of functions implementing the @method{is_absolute} method.  When successful: return @ctrue{} is
the pathname is absolute; otherwise return @cfalse{}.  If an error occurs (for example: because this
method is not implemented): raise an exception by performing a non--local exit to @var{L}.
@end deftypefn


@deftypefn {Function Prototype} bool {ccname_trait_method_type(ccstructs_pathname_T, is_relative)} (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Type of functions implementing the @method{is_relative} method.  When successful: return @ctrue{} is
the pathname is relative; otherwise return @cfalse{}.  If an error occurs (for example: because this
method is not implemented): raise an exception by performing a non--local exit to @var{L}.
@end deftypefn


@deftypefn {Function Prototype} bool {ccname_trait_method_type(ccstructs_pathname_T, is_normalised)} (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Type of functions implementing the @method{is_normalised} method.  When successful: return @ctrue{}
is the pathname has been normalised with a procedure not involving access to the file system;
otherwise return @cfalse{}.  If an error occurs (for example: because this method is not
implemented): raise an exception by performing a non--local exit to @var{L}.

Examples of normalisation for a Unix pathname: removal of redundant dots; removal of redundant
double--dots; removal of double--slashes.
@end deftypefn


@deftypefn {Function Prototype} bool {ccname_trait_method_type(ccstructs_pathname_T, is_realpath)} (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Type of functions implementing the @method{is_realpath} method.  When successful: return @ctrue{} is
the pathname has been normalised with a function like the standard @cfunc{realpath}; otherwise
return @cfalse{}.  If an error occurs (for example: because this method is not implemented): raise
an exception by performing a non--local exit to @var{L}.
@end deftypefn


@deftypefn {Function Prototype} ccstructs_dtor_T {ccname_trait_method_type(ccstructs_pathname_T, dtor)} (ccstructs_pathname_T @var{I})
Type of functions implementing the @method{dtor} method.  Return an instance of the
@objtype{ccstructs_dtor_T} trait that destroys the underlying pathname representation;
@ref{dtor, The @trait{dtor} trait}.
@end deftypefn


@deftypefn {Function Prototype} ccstructs_dumpable_T {ccname_trait_method_type(ccstructs_pathname_T, dumpable)} (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Type of functions implementing the @method{dumpable} method.  Return an instance of the
@objtype{ccstructs_dumpable_T} that prints the underlying pathname representation; @ref{dumpable,
The @trait{dumpable} trait}.  If an error occurs creating the trait (for example: because
the trait is not implemented): raise an exception by performing a non--local exit to @var{L}.
@end deftypefn


@deftypefn {Function Prototype} ccstructs_serialiser_T {ccname_trait_method_type(ccstructs_pathname_T, serialiser)} (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Type of functions implementing the @method{serialiser} method.  Return an instance of the
@objtype{ccstructs_serialiser_T} that serialises the underlying pathname representation;
@ref{serialiser, The @trait{serialiser} trait}.  If an error occurs creating the trait (for
example: because the trait is not implemented): raise an exception by performing a non--local
exit to @var{L}.
@end deftypefn


@deftypefn {Function Prototype} ccstructs_deserialiser_T {ccname_trait_method_type(ccstructs_pathname_T, deserialiser)} (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Type of functions implementing the @method{deserialiser} method.  Return an instance of the
@objtype{ccstructs_deserialiser_T} that deserialises the underlying pathname representation;
@ref{deserialiser, The @trait{deserialiser} trait}.  If an error occurs creating the trait
(for example: because the trait is not implemented): raise an exception by performing a
non--local exit to @var{L}.
@end deftypefn

@c page
@node pathname api
@section Programming trait for the @trait{pathname} trait


@deftypefun ccstructs_pathname_T {ccname_new(ccstructs_pathname_T)} (ccstructs_core_t const * @var{S}, ccname_trait_table_type(ccstructs_pathname_T) const * @var{M})
Trait constructor.  Return a new trait @struct{} given a pointer to the source @struct{} and
a pointer to the trait methods.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_pathname_self (ccstructs_pathname_T @var{I})
Return a pointer to the @struct{} to which the trait belongs.
@end deftypefun


@deftypefun ccmem_asciiz_t ccstructs_pathname_asciiz (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Apply the method @method{asciiz} to the trait instance.  Return an instance of
@objtype{ccmem_asciiz_t} holding an @asciiz{} representation of the pathname.  If an error occurs
generating the representation: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool ccstructs_pathname_is_static (ccstructs_pathname_T @var{I})
Apply the method @method{is_static} to the trait instance.
@end deftypefun


@deftypefun bool ccstructs_pathname_is_absolute (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Apply the method @method{is_absolute} to the trait instance.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool ccstructs_pathname_is_relative (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Apply the method @method{is_relative} to the trait instance.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool ccstructs_pathname_is_normalised (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Apply the method @method{is_normalised} to the trait instance.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool ccstructs_pathname_is_realpath (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Apply the method @method{is_realpath} to the trait instance.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccstructs_dtor_T {ccname_trait_new(ccstructs_dtor_T, ccstructs_pathname_T)} (ccstructs_pathname_T @var{I})
Apply the method @method{dtor} to the trait instance.  Build and return an instance of the
trait @objtype{ccstructs_dtor_T} that we can use to destroy the underlying pathname
representation; @ref{dtor, The @trait{dtor} trait}.
@end deftypefun


@deftypefun ccstructs_dumpable_T {ccname_trait_new(ccstructs_dumpable_T, ccstructs_pathname_T)} (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Apply the method @method{dumpable} to the trait instance.  Build and return an instance of the
trait @objtype{ccstructs_dumpable_T} acting upon the underlying pathname representation;
@ref{dumpable, The @trait{dtor} trait}.  If an error occurs creating the trait (for
example: because the trait is not implemented): raise an exception by performing a non--local
exit to @var{L}.
@end deftypefun


@deftypefun ccstructs_serialiser_T {ccname_trait_new(ccstructs_serialiser_T, ccstructs_pathname_T)} (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Apply the method @method{serialiser} to the trait instance.  Build and return an instance of the
trait @objtype{ccstructs_serialiser_T} acting upon the underlying pathname representation;
@ref{serialiser, The @trait{dtor} trait}.  If an error occurs creating the trait (for
example: because the trait is not implemented): raise an exception by performing a non--local
exit to @var{L}.
@end deftypefun


@deftypefun ccstructs_deserialiser_T {ccname_trait_new(ccstructs_deserialiser_T, ccstructs_pathname_T)} (cce_destination_t @var{L}, ccstructs_pathname_T @var{I})
Apply the method @method{deserialiser} to the trait instance.  Build and return an instance of
the trait @objtype{ccstructs_deserialiser_T} acting upon the underlying pathname representation;
@ref{deserialiser, The @trait{dtor} trait}.  If an error occurs creating the trait
(for example: because the trait is not implemented): raise an exception by performing a
non--local exit to @var{L}.
@end deftypefun

@c page
@node pathname simple
@section Simple implementations of a @trait{pathname} trait


The @value{PACKAGE} library implements a very simple and incomplete file system pathname
representation, which supports the @objtype{ccstructs_pathname_T} trait.  Most of the methods
will just raise an exception of type @objtype{cce_condition_unimplemented_t}.

@menu
* pathname simple typedefs::    Simple pathname: type definitions.
* pathname simple ctors::       Simple pathname: constructors.
* pathname simple gctors::      Simple pathname: guarded constructors.
* pathname simple traits::      Simple pathname: implemented traits.
* pathname simple samples::     Simple pathname: usage examples.
@end menu

@c page
@node pathname simple typedefs
@subsection Simple pathname: type definitions


@deftp {Struct Typedef} ccstructs_pathname_t
Type of simple file system pathname representation implemented by @value{PACKAGE}.
@end deftp

@c page
@node pathname simple ctors
@subsection Simple pathname: constructors


@subsubheading Constructors for embedded instances


@deftypefun void {ccname_init(ccstructs_pathname_t, from_asciiz)} (cce_destination_t @var{L}, ccstructs_pathname_t * @var{ptn}, ccmem_asciiz_t @var{rep})
Constructor function that initialises an already allocated @struct{} instance.  This function
initialises from an @asciiz{} representation; @ccmemoryref{ascii zero, Zero terminated strings}.  If
an error occurs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, from_ascii)} (cce_destination_t @var{L}, ccstructs_pathname_t * @var{ptn}, ccmem_ascii_t @var{rep})
Constructor function that initialises an already allocated @struct{} instance.  This function
initialises from an @ascii{} representation; @ccmemoryref{ascii non-zero, Non--zero terminated
strings}.  If an error occurs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, from_chars)} (cce_destination_t @var{L}, ccstructs_pathname_t * @var{ptn}, char const * @var{P})
Constructor function that initialises an already allocated @struct{} instance.  This function
initialises from a C pointer to an @asciiz{} representation.  If an error occurs: raise an exception
by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, copy)} (cce_destination_t @var{L}, ccstructs_pathname_t * @var{dst}, ccstructs_pathname_t const * @var{src})
Constructor function that initialises an already allocated @struct{} instance.  This function
initialises from an already built pathname instance.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, deserialisable)} (ccstructs_pathname_t * @var{ptn})
Constructor function that initialises an already allocated @struct{} instance.  This function
initialises in such a way that it allows for both finalisation and mutation from deserialisation.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Constructors for standalone instances


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, from_asciiz)} (cce_destination_t @var{L}, ccmem_asciiz_t @var{rep})
Constructor function that allocates the @struct{} on the heap using the standard memory allocator
implemented by CCMemory; @ccmemoryref{std, The standard allocator}.  This function initialises from
an @asciiz{} representation; @ccmemoryref{ascii zero, Zero terminated strings}.  If an error occurs:
raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, from_ascii)} (cce_destination_t @var{L}, ccmem_ascii_t @var{rep})
Constructor function that allocates the @struct{} on the heap using the standard memory allocator
implemented by CCMemory; @ccmemoryref{std, The standard allocator}.  This function initialises from
an @ascii{} representation; @ccmemoryref{ascii non-zero, Non--zero terminated strings}.  If an error
occurs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, from_chars)} (cce_destination_t @var{L}, char const * @var{P})
Constructor function that allocates the @struct{} on the heap using the standard memory allocator
implemented by CCMemory; @ccmemoryref{std, The standard allocator}.  This function initialises from
a C pointer to an @asciiz{} representation.  If an error occurs: raise an exception by performing a
non--local exit to @var{L}.
@end deftypefun


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, copy)} (cce_destination_t @var{L}, ccstructs_pathname_t const * @var{src})
Constructor function that allocates the @struct{} on the heap using the standard memory allocator
implemented by CCMemory; @ccmemoryref{std, The standard allocator}.  This function initialises from
an already built pathname representation.  If an error occurs: raise an exception by performing a
non--local exit to @var{L}.
@end deftypefun


@deftypefun {ccstructs_pathname_t *} {ccname_new(ccstructs_pathname_t, deserialisable)} (cce_destination_t @var{L})
Constructor function that allocates the @struct{} on the heap using the standard memory allocator
implemented by CCMemory; @ccmemoryref{std, The standard allocator}.  This function initialises in
such a way that it allows for both finalisation and mutation from deserialisation.  If an error
occurs: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node pathname simple gctors
@subsection Simple pathname: guarded constructors


@subsubheading Constructors for embedded instances


@deftypefun void {ccname_init(ccstructs_pathname_t, from_asciiz, guarded, clean)} (cce_destination_t @var{L}, ccstructs_clean_handler_t * @var{H}, ccstructs_pathname_t * @var{ptn}, ccmem_asciiz_t @var{rep})
Guarded instance constructor.  Initialise a struct already allocated on the stack or embedded into
an enclosing struct.  Initialise the internal pathname representation from an @asciiz{} block.
Register the instance for finalisation with the handler @var{H}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, from_asciiz, guarded, error)} (cce_destination_t @var{L}, ccstructs_error_handler_t * @var{H}, ccstructs_pathname_t * @var{ptn}, ccmem_asciiz_t @var{rep})
Guarded instance constructor.  Initialise a struct already allocated on the stack or embedded into
an enclosing struct.  Initialise the internal pathname representation from an @asciiz{} block.
Register the instance for finalisation with the handler @var{H}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, from_ascii, guarded, clean)} (cce_destination_t @var{L}, ccstructs_clean_handler_t * @var{H}, ccstructs_pathname_t * @var{ptn}, ccmem_ascii_t @var{rep})
Guarded instance constructor.  Initialise a struct already allocated on the stack or embedded into
an enclosing struct.  Initialise the internal pathname representation from an @ascii{} block.  Register
the instance for finalisation with the handler @var{H}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, from_ascii, guarded, error)} (cce_destination_t @var{L}, ccstructs_error_handler_t * @var{H}, ccstructs_pathname_t * @var{ptn}, ccmem_ascii_t @var{rep})
Guarded instance constructor.  Initialise a struct already allocated on the stack or embedded into
an enclosing struct.  Initialise the internal pathname representation from an @ascii{} block.  Register
the instance for finalisation with the handler @var{H}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, from_chars, guarded, clean)} (cce_destination_t @var{L}, ccstructs_clean_handler_t * @var{H}, ccstructs_pathname_t * @var{ptn}, char const * @var{P})
Guarded instance constructor.  Initialise a struct already allocated on the stack or embedded into
an enclosing struct.  Initialise the internal pathname representation from an @asciiz{} string pointer.
Register the instance for finalisation with the handler @var{H}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, from_chars, guarded, error)} (cce_destination_t @var{L}, ccstructs_error_handler_t * @var{H}, ccstructs_pathname_t * @var{ptn}, char const * @var{P})
Guarded instance constructor.  Initialise a struct already allocated on the stack or embedded into
an enclosing struct.  Initialise the internal pathname representation from an @asciiz{} string pointer.
Register the instance for finalisation with the handler @var{H}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, copy, guarded, clean)} (cce_destination_t @var{L}, ccstructs_clean_handler_t * @var{H}, ccstructs_pathname_t * @var{ptn}, ccstructs_pathname_t const * @var{src})
Guarded instance constructor.  Initialise a struct already allocated on the stack or embedded into
an enclosing struct.  Initialise the internal pathname representation from an already built pathname
representation.  Register the instance for finalisation with the handler @var{H}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, copy, guarded, error)} (cce_destination_t @var{L}, ccstructs_error_handler_t * @var{H}, ccstructs_pathname_t * @var{ptn}, ccstructs_pathname_t const * @var{src})
Guarded instance constructor.  Initialise a struct already allocated on the stack or embedded into
an enclosing struct.  Initialise the internal pathname representation from an already built pathname
representation.  Register the instance for finalisation with the handler @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Constructors for standalone instances


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, from_asciiz, guarded, clean)} (cce_destination_t @var{L}, ccstructs_clean_handler_t * @var{H}, ccmem_asciiz_t @var{rep})
Guarded instance constructor.  Allocate a new struct and initialise it.  Initialise the internal
pathname representation from an @asciiz{} block.  Register the instance for finalisation with the
handler @var{H}.
@end deftypefun


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, from_asciiz, guarded, error)} (cce_destination_t @var{L}, ccstructs_error_handler_t * @var{H}, ccmem_asciiz_t @var{rep})
Guarded instance constructor.  Allocate a new struct and initialise it.  Initialise the internal
pathname representation from an @asciiz{} block.  Register the instance for finalisation with the
handler @var{H}.
@end deftypefun


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, from_ascii, guarded, clean)} (cce_destination_t @var{L}, ccstructs_clean_handler_t * @var{H}, ccmem_ascii_t @var{rep})
Guarded instance constructor.  Allocate a new struct and initialise it.  Initialise the internal
pathname representation from an @ascii{} block.  Register the instance for finalisation with the
handler @var{H}.
@end deftypefun


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, from_ascii, guarded, error)} (cce_destination_t @var{L}, ccstructs_error_handler_t * @var{H}, ccmem_ascii_t @var{rep})
Guarded instance constructor.  Allocate a new struct and initialise it.  Initialise the internal
pathname representation from an @ascii{} block.  Register the instance for finalisation with the
handler @var{H}.
@end deftypefun


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, from_chars, guarded, clean)} (cce_destination_t @var{L}, ccstructs_clean_handler_t * @var{H}, char const * @var{P})
Guarded instance constructor.  Allocate a new struct and initialise it.  Initialise the internal
pathname representation from an @asciiz{} string pointer.  Register the instance for finalisation with
the handler @var{H}.
@end deftypefun


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, from_chars, guarded, error)} (cce_destination_t @var{L}, ccstructs_error_handler_t * @var{H}, char const * @var{P})
Guarded instance constructor.  Allocate a new struct and initialise it.  Initialise the internal
pathname representation from an @asciiz{} string pointer.  Register the instance for finalisation with
the handler @var{H}.
@end deftypefun


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, copy, guarded, clean)} (cce_destination_t @var{L}, ccstructs_clean_handler_t * @var{H}, ccstructs_pathname_t const * @var{src})
Guarded instance constructor.  Allocate a new struct and initialise it.  Initialise the internal
pathname representation from an already built pathname representation.  Register the instance for
finalisation with the handler @var{H}.
@end deftypefun


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, copy, guarded, error)} (cce_destination_t @var{L}, ccstructs_error_handler_t * @var{H}, ccstructs_pathname_t const * @var{src})
Guarded instance constructor.  Allocate a new struct and initialise it.  Initialise the internal
pathname representation from an already built pathname representation.  Register the instance for
finalisation with the handler @var{H}.
@end deftypefun

@c page
@node pathname simple traits
@subsection Simple pathname: implemented traits


@deftypefun ccstructs_dtor_T {ccname_trait_new(ccstructs_dtor_T, ccstructs_pathname_t)} (ccstructs_pathname_t const * @var{ptn})
Trait constructor for @objtype{ccstructs_dtor_T} as implemented by
@objtype{ccstructs_pathname_t}; @ref{dtor, The @trait{dtor} trait}.  The returned destructor
trait will work for both embedded and standalone instances of @objtype{ccstructs_pathname_t}.
@end deftypefun


@deftypefun ccstructs_pathname_T {ccname_trait_new(ccstructs_pathname_T, ccstructs_pathname_t)} (ccstructs_pathname_t const * @var{ptn})
Trait constructor for @objtype{ccstructs_pathname_T} as implemented by
@objtype{ccstructs_pathname_t}; @ref{pathname, The @trait{pathname} trait}.
@end deftypefun


@deftypefun ccstructs_serialiser_T {ccname_trait_new(ccstructs_serialiser_T, ccstructs_pathname_t)} (ccstructs_pathname_t const * @var{ptn})
Constructor for a @objtype{ccstructs_serialiser_T} trait that serialises an instance of
@objtype{ccstructs_pathname_t} into a memory block; @ref{serialiser, The @trait{serialiser}
trait}.
@end deftypefun


@deftypefun ccstructs_deserialiser_T {ccname_trait_new(ccstructs_deserialiser_T, ccstructs_pathname_t)} (ccstructs_pathname_t * @var{ptn})
Constructor for a @objtype{ccstructs_deserialiser_T} trait that deserialises an instance of
@objtype{ccstructs_pathname_t} from a memory block; @ref{deserialiser, The @trait{deserialiser}
trait}.
@end deftypefun


@deftypefun ccstructs_dumpable_T {ccname_trait_new(ccstructs_dumpable_T, ccstructs_pathname_t)} (ccstructs_pathname_t const * @var{ptn})
Constructor for a @objtype{ccstructs_dumpable_T} trait that prints the a representation of the
underlying @objtype{ccstructs_pathname_t} on the @stderr{} stream; @ref{dumpable, The
@trait{dumpable} trait}.
@end deftypefun

@c page
@node pathname simple samples
@subsection Simple pathname: usage examples


Let's see how we can build a standalone instance of @objtype{ccstructs_pathname_t} and use it
through the trait @objtype{ccstructs_pathname_T}:

@smallexample
char const *                  P = "/path/to/file.ext";
cce_location_t                L[1];
ccstructs_pathname_t const *  ptn;
ccstructs_pathname_T          ptn_T;
ccstructs_clean_handler_t     ptn_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  ptn   = ccname_new(ccstructs_pathname_t, from_chars)(L, P);
  ptn_T = ccname_trait_new(ccstructs_pathname_T, ccstructs_pathname_t)(ptn);
  ccstructs_init_and_register_handler(L, ptn_H,
    ccname_trait_new(ccstructs_dtor_T, ccstructs_pathname_T)(ptn_T));

  ...
  cce_run_body_handlers(L);
@}
@end smallexample

We can dump to @stderr{} a string representation of the instance with:

@smallexample
ccstructs_dumpable_T  W =
  ccname_trait_new(ccstructs_dumpable_T, ccstructs_pathname_T)(L, ptn_T);

ccstructs_dumpable_dump(L, W);
@end smallexample

We can create an @asciiz{} representation of the pathname with:

@smallexample
ccmem_asciiz_t  rep = ccstructs_pathname_asciiz(L, I);
@end smallexample

We can serialise the pathname with:

@smallexample
ccstructs_serialiser_T  S =
  ccname_trait_new(ccstructs_serialiser_T, ccstructs_pathname_T)(L, ptn_T);

/* Allocate memory for the serialisation. */
ccmem_clean_handler_t  M_H[1];
ccmem_block_t          M =
  ccmem_block_malloc_guarded(L, M_H, ccmem_standard_allocator,
    ccstructs_serialiser_required_size(S));

/* Serialise the struct. */
ccmem_block_t  M_leftover = ccstructs_serialiser_write(L, S, M);
@end smallexample

@noindent
and we can deserialise a pathname instance from a memory block @code{M} with:

@smallexample
ccmem_block_t            M = ...
ccmem_block_t            M_leftover;
ccstructs_pathname_t *   other;
ccstructs_pathname_T     other_T;
ccstructs_deserialiser_T other_D;

other   = ccname_new(ccstructs_pathname_t, deserialisable)(L);
other_T = ccname_trait_new(ccstructs_pathname_T,
                           ccstructs_pathname_t)(other);
other_D = ccname_trait_new(ccstructs_deserialiser_T,
                           ccstructs_pathname_T)(L, other_T);

M_leftover = ccstructs_deserialiser_read(L, other_D, M);
@end smallexample

@c page
@node utils
@chapter Utility definitions


@defmac CCSTRUCTS_PC (@var{POINTER_TYPE}, @var{POINTER_NAME}, @var{EXPRESSION})
Preprocessor macro used to define pointer variables initialised with a cast expression.  It expands
to:

@example
POINTER_TYPE * POINTER_NAME = (POINTER_TYPE *) (EXPRESSION)
@end example

For example, the macro use:

@example
CCSTRUCTS_PC(ccstructs_descriptor_test_failure_t, C, _C);
@end example

@noindent
expands into:

@example
ccstructs_descriptor_test_failure_t * C = \
   (ccstructs_descriptor_test_failure_t *) (_C);
@end example
@end defmac


@defmac CCSTRUCTS_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  If the symbol
@code{__GNUC__} is defined, the expansion is:

@example
__attribute__((__unused__))
@end example

@noindent
otherwise the expansion is the empty string.
@end defmac

@c page
@node ccnames
@appendix Automatically generated @api{} names


The header file @file{ccnames.h} defines a set of macros that generate, at expansion time,
identifiers for functions and variables that have ``well known'' roles in the @api{} of the
CCLibraries projects.

@menu
* ccnames struct common::       Well known functions for @struct{} types.
* ccnames struct table::        Tables of methods for @struct{} types.
* ccnames trait::               Well known names for trait types.
@end menu

@c page
@node ccnames struct common
@appendixsec Well known functions for @struct{} types


The macros for ``well known functions'' define an @api{} for the basic operations upon a data
@struct{}.  The following macros are defined in the header file @file{ccnames.h}.


@defmac ccname_init (@var{STRUCT_TYPE})
@defmacx ccname_init (@var{STRUCT_TYPE}, @var{VARIANT})
@defmacx ccname_init (@var{STRUCT_TYPE}, @vari{VARIANT}, @varii{VARIANT})
@defmacx ccname_init (@var{STRUCT_TYPE}, @vari{VARIANT}, @variii{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
@api{} function @cfunc{init}.

Functions with this name are constructors for @struct{} instances allocated on the stack or embedded
into enclosing @struct{} instances.  They allocate all the asynchronous resources and initialise the
@struct{} fields.
@end defmac


@defmac ccname_final (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{final}.

Functions with this name are destructors for @struct{} instances allocated on the stack or embedded
into enclosing @struct{} instances.  They release all the asynchronous resources associated to the
@struct{} fields.
@end defmac


@defmac ccname_alloc (@var{STRUCT_TYPE})
@defmacx ccname_alloc (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
@api{} function @cfunc{alloc}.

Functions of this type are memory allocators for @struct{} instances allocated on the heap.  They
might perform the allocation using the @api{} of the library CCMemory.
@end defmac


@defmac ccname_release (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{release}.

Functions of this type are memory releasers for @struct{} instances allocated on the heap.  They
might perform the release using the @api{} of the library CCMemory.
@end defmac


@defmac ccname_new (@var{STRUCT_TYPE})
@defmacx ccname_new (@var{STRUCT_TYPE}, @var{VARIANT})
@defmacx ccname_new (@var{STRUCT_TYPE}, @vari{VARIANT}, @varii{VARIANT})
@defmacx ccname_new (@var{STRUCT_TYPE}, @vari{VARIANT}, @variii{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
@api{} function @cfunc{new}.

Functions with this name are constructors for @struct{} instances allocated on the heap.  The memory
allocation is performed by calling the @cfunc{alloc} function.  The initialisation of the fields is
performed by calling the @cfunc{init} function.
@end defmac


@defmac ccname_delete (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{delete}.

Functions with this name are destructors for @struct{} instances allocated on the heap.  The
finalisation of the fields is performed by calling the @cfunc{final} function.  The memory release
is performed by calling the @cfunc{release} function.
@end defmac


An example of common function implementation for @struct{} types:

@smallexample
#include <ccexceptions.h>
#include <ccmemory.h>
#include <ccnames.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef struct my_coords_t      my_coords_t;

struct my_coords_t @{
  double        X;
  double        Y;
@};

void
ccname_init(my_coords_t, rec) (my_coords_t * S, double X, double Y)
@{
  S->X = X;
  S->Y = Y;
@}

void
ccname_init(my_coords_t, pol) (my_coords_t * S, double RHO, double THETA)
@{
  S->X = RHO * cos(THETA);
  S->Y = RHO * sin(THETA);
@}

void
ccname_final(my_coords_t) (my_coords_t * S)
@{
@}

static my_coords_t *
ccname_alloc(my_coords_t) (cce_destination_t L)
@{
  return (my_coords_t *)ccmem_std_malloc(L, sizeof(my_coords_t));
@}

static void
ccname_release(my_coords_t) (my_coords_t * S)
@{
  ccmem_std_free(S);
@}

my_coords_t *
ccname_new(my_coords_t, rec) (cce_destination_t L, double X, double Y)
@{
  my_coords_t * S = ccname_alloc(my_coords_t)(L);

  ccname_init(my_coords_t, rec)(S, X, Y);
  return S;
@}

my_coords_t *
ccname_new(my_coords_t, pol) (cce_destination_t L, double RHO, double THETA)
@{
  my_coords_t * S = ccname_alloc(my_coords_t)(L);

  ccname_init(my_coords_t, pol)(S, RHO, THETA);
  return S;
@}

void
ccname_delete(my_coords_t) (my_coords_t * S)
@{
  ccname_final(my_coords_t)(S);
  ccname_release(my_coords_t)(S);
@}

int
main (void)
@{
  cce_location_t        L[1];
  my_coords_t *         S;

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    S = ccname_new(my_coords_t, rec)(L, 1.0, 2.0);

    printf("X=%f, Y=%f\n", S->X, S->Y);
    ccname_delete(my_coords_t)(S);
  @}
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node ccnames struct table
@appendixsec Tables of methods for @struct{} types


The macros for the ``table of methods known functions'' define an @api{} to implement a table of
methods in a data @struct{}: every instance of the @struct{} type is meant to hold a pointer to a
statically allocated @struct{} which in turn holds pointers to method functions.  The following
macros are defined in the header file @file{ccnames.h}.


@defmac ccname_table_type (@var{STRUCT_TYPE})
@defmacx ccname_table_type (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
methods table type for the @struct{} type.
@end defmac


@defmac ccname_table (@var{STRUCT_TYPE})
@defmacx ccname_table (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
methods table for the @struct{} type.
@end defmac


@defmac ccname_method_type (@var{STRUCT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given a @struct{} type name, an optional variant specification, and a method name: expand into the
type name of that variant of the method function for the @struct{} type.
@end defmac


@defmac ccname_method (@var{STRUCT_TYPE}, @var{METHOD_NAME})
@defmacx ccname_method (@var{STRUCT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given a @struct{} type name, an optional variant specification, and a method name: expand into the
name of that variant of the method for that @struct{} type.
@end defmac


An example of methods table implementation for @struct{} types:

@smallexample
#include <ccexceptions.h>
#include <ccnames.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct my_coords_t                      my_coords_t;
typedef struct ccname_table_type(my_coords_t)   ccname_table_type(my_coords_t);

typedef void ccname_method_type(my_coords_t, print) (my_coords_t * S, FILE * stream);

struct my_coords_t @{
  ccname_table_type(my_coords_t) const * methods;
  double        X;
  double        Y;
@};

struct ccname_table_type(my_coords_t) @{
  ccname_method_type(my_coords_t, print) * print_rec;
  ccname_method_type(my_coords_t, print) * print_pol;
@};

static void
ccname_method(my_coords_t, print_rec) (my_coords_t * S, FILE * stream)
@{
  fprintf(stream, "X=%f, Y=%f\n", S->X, S->Y);
@}

static void
ccname_method(my_coords_t, print_pol) (my_coords_t * S, FILE * stream)
@{
  double        RHO   = hypot(S->X, S->Y);
  double        THETA = atan2(S->Y, S->X);

  fprintf(stream, "RHO=%f, THETA=%f\n", RHO, THETA);
@}

static ccname_table_type(my_coords_t) const ccname_table(my_coords_t) = @{
  .print_rec    = ccname_method(my_coords_t, print_rec),
  .print_pol    = ccname_method(my_coords_t, print_pol)
@};

void
ccname_init(my_coords_t, rec) (my_coords_t * S, double X, double Y)
@{
  S->methods = &ccname_table(my_coords_t);
  S->X = X;
  S->Y = Y;
@}

void
ccname_init(my_coords_t, pol) (my_coords_t * S, double RHO, double THETA)
@{
  S->methods = &ccname_table(my_coords_t);
  S->X = RHO * cos(THETA);
  S->Y = RHO * sin(THETA);
@}
@end smallexample

@c page
@node ccnames trait
@appendixsec Well known names for trait types.


The macros for ``well known trait functions'' define an @api{} to implement trait @struct{}
types; an trait is a set of operations we can apply to a data @struct{}; multiple data @struct{}
types can implement multiple traits.  The following macros are defined in the header file
@file{ccnames.h}.


@defmac ccname_trait_new_type (@var{TRAIT_TYPE})
@defmacx ccname_trait_new_type (@var{TRAIT_TYPE}, @var{STRUCT_TYPE})
@defmacx ccname_trait_new_type (@var{TRAIT_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT})
Given an trait type name, an optional struct name and an optional variant specification: expand
into the function type name of trait implementation constructors.  Constructors of such type
must build instances of @var{TRAIT_TYPE} as implemented by @var{STRUCT_TYPE}, as specified for the
variant @var{VARIANT}.
@end defmac


@defmac ccname_trait_new (@var{TRAIT_TYPE}, @var{STRUCT_TYPE})
@defmacx ccname_trait_new (@var{TRAIT_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT})
Given an trait type name, a struct type name, an optional variant specification: expand into the
name of the @api{} function @cfunc{new} that instantiates that variant of the trait for the
@struct{}.
@end defmac


@defmac ccname_trait_table_type (@var{TRAIT_TYPE})
@defmacx ccname_trait_table_type (@var{TRAIT_TYPE}, @var{VARIANT})
Given an trait type name and an optional variant specification: expand into the name of the
methods table type for the trait type.
@end defmac


@defmac ccname_trait_table (@var{TRAIT_TYPE}, @var{STRUCT_TYPE})
@defmacx ccname_trait_table (@var{TRAIT_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT})
Given an trait type name, a struct type name, and an optional variant specification: expand into
the name of the methods table for that variant of the trait implementation for the @struct{}
type.
@end defmac


@defmac ccname_trait_method_type (@var{TRAIT_TYPE}, @var{METHOD_NAME})
@defmacx ccname_trait_method_type (@var{TRAIT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given an trait type name, an optional variant specification, and a method name: expand into the
type name of the method function for that variant of the trait implementation.
@end defmac


@defmac ccname_trait_method (@var{TRAIT_TYPE}, @var{STRUCT_TYPE}, @var{METHOD_NAME})
@defmacx ccname_trait_method (@var{TRAIT_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given an trait type name, a struct type name, an optional variant specification, and a method
name: expand into the name of the method function for that variant of the trait implementation
for the struct type.
@end defmac


Let's say we have this @struct{} definition:

@smallexample
typedef struct my_coords_t      my_coords_t;

struct my_coords_t @{
  double        X;
  double        Y;
@};
@end smallexample

@noindent
and we want to define an trait type @objtype{my_printable_T} to print the @struct{} on a
standard stream, both in rectangular and polar forms.

Every trait must have a @struct{} acting as table of pointers to functions, whose functions
implements the trait methods.  The trait @struct{} type is unique, the methods table
@struct{} type is unique; for every data @struct{} that implements the trait: we need a methods
table and an trait constructor.

The trait @struct{} type and the methods table @struct{} type are defined as follows:

@smallexample
typedef struct my_printable_T   my_printable_T;
typedef struct ccname_trait_table_type(my_printable_T) \
  ccname_trait_table_type(my_printable_T);

struct my_printable_T @{
  ccname_trait_table_type(my_printable_T)  const * methods;
  ccstructs_core_t                         const * self;
@};

typedef void ccname_trait_method_type(my_printable_T, print) \
  (my_printable_T I, FILE * stream);

struct ccname_trait_table_type(my_printable_T) @{
  ccname_trait_method_type(my_printable_T, print) * print_rec;
  ccname_trait_method_type(my_printable_T, print) * print_pol;
@};
@end smallexample

The @objtype{my_printable_T} trait @api{} is defined as follows:

@smallexample
my_printable_T
my_printable_new (ccstructs_core_t const * S,
                  ccname_trait_table_type(my_printable_T) const * M)
@{
  my_printable_T        I = @{
    .methods    = M,
    .self       = S
  @};
  return I;
@}

ccstructs_core_t const *
my_printable_self (my_printable_T I)
@{
  return I.self;
@}

void
my_printable_print_rec (my_printable_T I, FILE * stream)
@{
  I.methods->print_rec(I, stream);
@}

void
my_printable_print_pol (my_printable_T I, FILE * stream)
@{
  I.methods->print_pol(I, stream);
@}
@end smallexample

The implementation of @objtype{my_printable_T} for the data @struct{} @objtype{my_coords_t} is
defined as follows:

@smallexample
static void
ccname_trait_method(my_printable_T, my_coords_t, print_rec) (my_printable_T I, FILE * stream)
@{
  CCSTRUCTS_PC(my_coords_t, S, my_printable_self(I));

  fprintf(stream, "X=%f, Y=%f\n", S->X, S->Y);
@}

static void
ccname_trait_method(my_printable_T, my_coords_t, print_pol) (my_printable_T I, FILE * stream)
@{
  CCSTRUCTS_PC(my_coords_t, S, my_printable_self(I));
  double        RHO   = hypot(S->X, S->Y);
  double        THETA = atan2(S->Y, S->X);

  fprintf(stream, "RHO=%f, THETA=%f\n", RHO, THETA);
@}

static ccname_trait_table_type(my_printable_T) const ccname_trait_table(my_printable_T, my_coords_t) = @{
  .print_rec    = ccname_trait_method(my_printable_T, my_coords_t, print_rec),
  .print_pol    = ccname_trait_method(my_printable_T, my_coords_t, print_pol)
@};

my_printable_T
ccname_trait_new(my_printable_T, my_coords_t) (my_coords_t * S)
@{
  return my_printable_new(ccstructs_core(S), &ccname_trait_table(my_printable_T, my_coords_t));
@}
@end smallexample

We can use the trait as follows:

@smallexample
int
main (void)
@{
  cce_location_t        L[1];
  my_coords_t *         S;
  my_printable_T        I;

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    S = ccname_new(my_coords_t, rec)(L, 1.0, 2.0);
    I = ccname_trait_new(my_printable_T, my_coords_t)(S);

    my_printable_print_rec(I, stdout);
    my_printable_print_pol(I, stdout);
    ccname_delete(my_coords_t)(S);
  @}
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
the package CCExceptions is available at:

@center @url{https://github.com/marcomaggi/ccexceptions/}

@noindent
the package CCMemory is available at:

@center @url{https://github.com/marcomaggi/ccmemory/}

@noindent
the package CCTests is available at:

@center @url{https://github.com/marcomaggi/cctests/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

