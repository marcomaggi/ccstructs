\input texinfo.tex
@c %**start of header
@setfilename ccstructs.info
@settitle CCStructs
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@macro method{NAME}
@cfunc{\NAME\}
@end macro

@macro iface{NAME}
@code{\NAME\}
@end macro

@macro ccmemoryref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,ccmemory}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCStructs

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCStructs

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccstructs

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2018, 2019

@c ------------------------------------------------------------

@set CCEXCEPTIONS_VERSION       0.8.0
@set CCMEMORY_VERSION           0.2.1
@set CCTESTS_VERSION            0.3.0

@set GITHUB_URL                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing common programming interfaces for C data structures.

This package supports @posix{} platforms.  This package depends on the external packages:
CCExceptions, at least version @value{CCEXCEPTIONS_VERSION}; CCMemory, at least version
@value{CCMEMORY_VERSION}.  To run the test suite: this package depends upon the external package
CCTests, at least version @value{CCTESTS_VERSION}.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccstructs: (ccstructs).       Common interfaces for C structs.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* core::                        Core type definitions.
* dtor::                        The @iface{destructor} interface.
* dumpable::                    The @iface{dumpable} interface.
* serialise::                   The @iface{serialise} and @iface{deserialise} interface.
* pathname::                    The @iface{pathname} interface.
* utils::                       Utility definitions.

Appendices

* ccnames::                     Automatically generated @api{} names.
* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing common programming interfaces for C data structures.

This package supports @posix{} platforms.  This package depends on the packages: CCExceptions, at
least version @value{CCEXCEPTIONS_VERSION}; CCMemory, at least version @value{CCMEMORY_VERSION}.  To
run the test suite: this package depends upon the package CCTests, at least version
@value{CCTESTS_VERSION}.

@value{PACKAGE} installs the header files @file{ccstructs.h} and @file{ccnames.h}.  All the function
names in the @api{} are prefixed with @code{ccstructs_} or @code{ccname_}; all the preprocessor
symbol names are prefixed with @code{CCSTRUCTS_} or @code{CCNAME_}; all the type names are prefixed
with @code{ccstructs_} and suffixed with @code{_t} or @code{_I}.

@menu
* overview linking::            Linking code with the library.
* overview ccnames::            The CCNames @api{}.
* overview examples::           Implementation examples.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCSTRUCTS],[ccstructs >= 0.1.0])
@end example

@noindent
which will set the variables @code{CCSTRUCTS_LIBS} and @code{CCSTRUCTS_CFLAGS}.  To avoid
problems with @command{pkg-config}, we need to remember that:

@itemize
@item
The macro file defining @code{PKG_CHECK_MODULES} is installed by the package @code{pkg-config}; such
file usually is in one of the locations:

@center @file{/usr/share/aclocal/pkg.m4}
@center @file{/usr/local/share/aclocal/pkg.m4}

@item
The macro file is located by @command{aclocal}, which in turn is installed by the package @gnu{}
Automake; @command{aclocal} is used by @command{autoreconf}.  We must make sure that
@command{aclocal} finds the installed macro files; for this purpose we can use the environment
variable @env{ACLOCAL_PATH}; under a Bourne shell we can do this with:

@example
export ACLOCAL_PATH=/usr/local/share/aclocal:/usr/share/aclocal
@end example
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccstructs],[ccstructs_version_string],,
  [AC_MSG_FAILURE([test for CCStructs library failed])])
AC_CHECK_HEADERS([ccstructs.h],,
  [AC_MSG_FAILURE([test for CCStructs header failed])])
@end example

@c page
@node overview ccnames
@section The CCNames @api{}


This package includes and uses the header file @file{ccname.h}, @ref{ccnames, Automatically
generated @api{} names}.  This header defines a set of preprocessor macros we can use to build
function names and @struct{} type names having a ``well known'' role in the @api{} associated to
data @struct{} types and interfaces.

It is weird and foreign.  It is not for everyone.

@c page
@node overview examples
@section Implementation examples


The source distribution comes with some implementation examples under the directory @file{examples}.
That code is meant to be a starting point when implementing the interfaces defined by
@value{PACKAGE}: we should copy it and adapt it to our needs.  Really!

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccstructs_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int ccstructs_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccstructs_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int ccstructs_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node core
@chapter Core type definitions


@value{PACKAGE} offers an @api{} to handle @struct{} values.  The library cannot reference the
concrete types of @struct{} the client libraries will use, so it just defines a placeholder for
them.


@deftp {Struct Typedef} ccstructs_core_t
Type of @struct{} values used as argument to @value{PACKAGE} functions.  This is just a forward type
declaration: there is no actual declaration of this type.
@end deftp


When using this type we need to explicitly cast a pointer to client @struct{} values to a pointer to
@objtype{ccstruct_core_t}.  For example, when defining a constructor for the @iface{dumpable}
interface:

@example
ccstructs_dumpable_I
ccname_iface_new(ccstructs_dumpable_I, spiffy_t) (spiffy_t * S)
@{
  return ccname_new(ccstructs_dumpable_I)(ccstructs_core(S),
    &ccname_iface_table(ccstructs_dumpable_I, spiffy_t));
@}
@end example


@deftypefun {ccstructs_core_t const *} ccstructs_core (void const * @var{S})
Cast the pointer @var{S} to @code{ccstructs_core_t *}.
@end deftypefun

@c page
@node dtor
@chapter The @iface{destructor} interface


The @iface{destructor} interface provides a uniform way to call the destructors of a @struct{} type.
The best way to use the @iface{destructor} interface is through the exception handlers @api{},
@ref{dtor handlers, Exception handlers}.

@menu
* dtor typedefs::               @iface{destructor} interface: type definitions.
* dtor operations::             @iface{destructor} interface: operations.
* dtor handlers::               Exception handlers.
* dtor sample::                 Example of @iface{destructor} interface
                                implementation.
@end menu

@c page
@node dtor typedefs
@section @iface{destructor} interface: type definitions


@deftp {Struct Typedef} ccstructs_dtor_I
Type of the @iface{destructor} interface @struct{}.  Instances of this type are meant to be handed
by value to function calls.
@end deftp


@deftp {Struct Typedef} {ccname_iface_table_type(ccstructs_dtor_I)}
Type of methods table for the @iface{destructor} interface.  It has the following fields:

@table @code
@item ccname_iface_method_type(ccstructs_dtor_I, final) * final
Pointer to function implementing the @method{final} method.

@item ccname_iface_method_type(ccstructs_dtor_I, release) * release
Pointer to function implementing the @method{release} method.
@end table
@end deftp


@deftypefn {Function Prototype} void {ccname_iface_method_type(ccstructs_dtor_I, final)} (ccstructs_dtor_I @var{I})
Type of functions implementing the @method{final} method.  Release all the asynchronous resources
owned by the fields of the @struct{}, if any.  The @struct{} itself is left alone.
@end deftypefn


@deftypefn {Function Prototype} void {ccname_iface_method_type(ccstructs_dtor_I, release)} (ccstructs_dtor_I @var{I})
Type of functions implementing the @method{release} method.  This method releases the memory
allocated for the @struct{} itself, if needed; if a @struct{} is allocated on the stack or embedded
into an enclosing @struct{}: this method should do nothing.
@end deftypefn

@c page
@node dtor operations
@section @iface{destructor} interface: operations


@deftypefun ccstructs_dtor_I {ccname_new(ccstructs_dtor_I)} (ccstructs_core_t const * @var{S}, ccname_iface_table_type(ccstructs_dtor_I) const * @var{M})
Build and return a new @iface{destructor} interface instance as implemented for the @struct{} type
of @var{S}.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_dtor_self (ccstructs_dtor_I @var{I})
Return a pointer to the subject @struct{} to which the interface belongs.
@end deftypefun


@deftypefun void ccstructs_dtor_delete (ccstructs_dtor_I @var{I})
Apply the @method{final} method to the subject @struct{}, then apply the @method{release} method to
the subject @struct{}.
@end deftypefun

@c page
@node dtor handlers
@section Exception handlers


The best way to use the @iface{destructor} interface is through the exception handlers @api{}.


@deftp {Struct Typedef} ccstructs_clean_handler_t
Type of @struct{} usable has clean handler with the facilities of the CCExceptions library.
@end deftp


@deftp {Struct Typedef} ccstructs_error_handler_t
Type of @struct{} usable has error handler with the facilities of the CCExceptions library.
@end deftp


@deftypefun void ccstructs_clean_handler_init (cce_destination_t @var{L}, ccstructs_clean_handler_t * @var{H}, ccstructs_dtor_I @var{I})
Initialise the exception handler @var{H} to apply @cfunc{ccstructs_dtor_delete} to @var{I}, in the
context of the location @var{L}.
@end deftypefun


@deftypefun void ccstructs_error_handler_init (cce_destination_t @var{L}, ccstructs_error_handler_t * @var{H}, ccstructs_dtor_I @var{I})
Initialise the exception handler @var{H} to apply @cfunc{ccstructs_dtor_delete} to @var{I}, in the
context of the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccstructs_handler_init (cce_destination_t @var{L}, @var{H}, ccstructs_dtor_I @var{I})
Initialise the exception handler @var{H} to apply @cfunc{ccstructs_dtor_delete} to @var{I}, in the
context of the location @var{L}.  If @var{H} is a pointer of type:

@table @code
@item ccstructs_clean_handler_t
The macro use expands to a call to @cfunc{ccstructs_clean_handler_init}.

@item ccstructs_error_handler_t
The macro use expands to a call to @cfunc{ccstructs_error_handler_init}.
@end table
@end deftypefn

@c page
@node dtor sample
@section Example of @iface{destructor} interface implementation


As example, let's consider this @struct{} definition:

@example
typedef struct alpha_t    alpha_t;

struct alpha_t @{
  void *  pointer;
@};
@end example

@noindent
for it we define a constructor as follows:

@example
alpha_t *
ccname_new(alpha_t) (cce_destination_t upper_L, int init)
@{
  cce_location_t        L[1];
  cce_error_handler_t   S_H[1];
  alpha_t *               S;

  if (cce_location(L)) @{
    cce_run_catch_handlers_raise(L, upper_L);
  @} else @{
    S           = cce_sys_malloc_guarded(L, S_H, sizeof(alpha_t));
    S->pointer  = cce_sys_malloc(L, 256);
    memset(S->pointer, init, 256);
    cce_run_body_handlers(L);
  @}
  return S;
@}
@end example

@noindent
we can implement the @iface{destructor} interface as follows:

@smallexample
static void
ccname_iface_method(ccstructs_dtor_I, alpha_t, final) (ccstructs_dtor_I I)
@{
  CCSTRUCTS_PC(alpha_t, S, ccstructs_dtor_self(I));

  free(S->pointer);
@}

static void
ccname_iface_method(ccstructs_dtor_I, alpha_t, release) (ccstructs_dtor_I I)
@{
  CCSTRUCTS_PC(alpha_t, S, ccstructs_dtor_self(I));

  free(S);
@}

static ccname_iface_table_type(ccstructs_dtor_I) const \
    ccname_iface_table(ccstructs_dtor_I, alpha_t) = @{
  .final   = ccname_iface_method(ccstructs_dtor_I, alpha_t, final),
  .release = ccname_iface_method(ccstructs_dtor_I, alpha_t, release)
@};

ccstructs_dtor_I
ccname_iface_new(ccstructs_dtor_I, alpha_t) (alpha_t const * S)
@{
  return ccname_new(ccstructs_dtor_I)(ccstructs_core(S),
    &ccname_iface_table(ccstructs_dtor_I, alpha_t));
@}
@end smallexample

@noindent
and we can use it with the exception handlers as follows:

@smallexample
cce_location_t             L[1];
alpha_t *                  S;
ccstructs_clean_handler_t  I_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  S = ccname_new(alpha_t)(L, 123);
  ccstructs_handler_init(L, I_H,
    ccname_iface_new(ccstructs_dtor_I, alpha_t)(S));

  ...
  cce_run_body_handlers(L);
@}
@end smallexample

Now we can easily define a guarded constructor:

@smallexample
alpha_t *
two_new_guarded_clean (cce_destination_t L,
                       ccstructs_clean_handler_t * I_H, int init)
@{
  alpha_t * S = ccname_new(alpha_t)(L, init);
  ccstructs_handler_init(L, I_H,
    ccname_iface_new(ccstructs_dtor_I, alpha_t)(S));
  return S;
@}

alpha_t *
two_new_guarded_error (cce_destination_t L,
                       ccstructs_error_handler_t * I_H, int init)
@{
  alpha_t * S = ccname_new(alpha_t)(L, init);
  ccstructs_handler_init(L, I_H,
    ccname_iface_new(ccstructs_dtor_I, alpha_t)(S));
  return S;
@}

#define two_new_guarded(L,I_H,S)                           \
  _Generic((I_H),                                          \
    ccstructs_clean_handler_t *: two_new_guarded_clean,    \
    ccstructs_error_handler_t *: two_new_guarded_error)(L,I_H,S)
@end smallexample

@c page
@node dumpable
@chapter The @iface{dumpable} interface


The @iface{dumpable} interface, represented by the type @objtype{ccstructs_dumpable_I}, is meant to
write an object to some output channel, mostly for inspection and debugging purposes; this interface
is neither for presentation to the end user of a program, nor for memorisation on a storage device.

@menu
* dumpable typedefs::           @iface{dumpable} interface: type definitions.
* dumpable operations::         @iface{dumpable} interface: operations.
* dumpable sample::             Example of @iface{dumpable} interface
                                implementation
@end menu

@c page
@node dumpable typedefs
@section @iface{dumpable} interface: type definitions


@deftp {Struct Typedef} ccstructs_dumpable_I
Type of the @iface{dumpable} interface.  Instances of this type are meant to be handed by value to
function calls.
@end deftp


@deftp {Struct Typedef} {ccname_iface_table_type(ccstructs_dumpable_I)}
Type of methods table for the @iface{dumpable} interface.  It has the following fields:

@table @code
@item ccname_iface_method_type(ccstructs_dumpable_I, dump) * dump
Pointer to function implementing the @method{dump} method.
@end table
@end deftp


@deftypefn {Function Prototype} void {ccname_iface_method_type(ccstructs_dumpable_I, dump)} (cce_destination_t @var{L}, ccstructs_dumpable_I @var{I})
Type of functions implementing the @method{dump} method.  Functions of this type write a
representation of the object to an output channel; it is responsibility of this method to select
which output channel to use.  If an error occurs: raise an exception by performing a non--local exit
to @var{L}.
@end deftypefn


@c page
@node dumpable operations
@section @iface{dumpable} interface: operations


@deftypefun ccstructs_dumpable_I {ccname_new(ccstructs_dumpable_I)} (ccstructs_core_t const * @var{S}, ccname_iface_table_type(ccstructs_dumpable_I) const * @var{M})
Interface constructor.  Return a new interface @struct{} given a pointer to the source @struct{} and
a pointer to the interface methods.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_dumpable_self (ccstructs_dumpable_I @var{I})
Return a pointer to the @struct{} to which the interface belongs.
@end deftypefun


@deftypefun void ccstructs_dumpable_dump (cce_destination_t @var{L}, ccstructs_dumpable_I @var{I})
Apply the method @method{dump} to the @struct{}.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node dumpable sample
@section Example of @iface{dumpable} interface implementation


Let's say we have this @struct{} definition:

@example
typedef struct spiffy_t        spiffy_t;

struct spiffy_t @{
  int   alpha;
  int   beta;
@};
@end example

@noindent
we can implement a @iface{dumpable} interface as follows:

@smallexample
static void
ccname_iface_method(ccstructs_dumpable_I, spiffy_t, dump)
  (cce_destination_t L, ccstructs_dumpable_I I)
@{
  CCSTRUCTS_PC(spiffy_t, S, I.self);
  int   rv;

  errno = 0;
  rv = fprintf(stderr, "spiffy_t: alpha=%d, beta=%d\n", S->alpha, S->beta);
  if (0 > rv) @{
    cce_raise(L, cce_condition_new_errno_clear());
  @}
@}

static ccname_iface_table_type(ccstructs_dumpable_I) const
    ccname_iface_table(ccstructs_dumpable_I, spiffy_t) = @{
  .dump = ccname_iface_method(ccstructs_dumpable_I, spiffy_t, dump)
@};

ccstructs_dumpable_I
ccname_iface_new(ccstructs_dumpable_I, spiffy_t) (spiffy_t * S)
@{
  return ccname_iface_new(ccstructs_dumpable_I)(ccstructs_core(S),
    &ccname_iface_table(ccstructs_dumpable_I, spiffy_t));
@}
@end smallexample

@noindent
then we can use the interface as follows:

@smallexample
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  spiffy_t   S = @{
    .alpha    = 1,
    .beta     = 2
  @};
  ccstructs_dumpable_I  I = ccname_iface_new(ccstructs_dumpable_I, spiffy_t)(&S);

  ccstructs_dumpable_dump(L, I);
  cce_run_body_handlers(L);
@}
@end smallexample

@c page
@node serialise
@chapter The @iface{serialise} and @iface{deserialise} interfaces


The @iface{serialise} interface, represented by the type @objtype{ccstructs_serialise_I}, allows us
to serialise a @struct{} into a destination storage.  The @iface{deserialise} interface, represented
by the type @objtype{ccstructs_deserialise_I}, allows us to deserialise a @struct{} from a source
storage.

For implementation examples we should look in the source distribution of @value{PACKAGE}.

@menu
* serialise typedefs::          @iface{serialise} interface: type definitions.
* serialise operations::        @iface{serialise} interface: operations.
* deserialise typedefs::        @iface{deserialise} interface: type definitions.
* deserialise operations::      @iface{deserialise} interface: operations.
@end menu

@c page
@node serialise typedefs
@section @iface{serialise} interface: type definitions


@deftp {Struct Typedef} ccstructs_serialise_I
Type of the @iface{serialise} interface.  Instances of this type are meant to be handed by value
to function calls.
@end deftp


@deftp {Struct Typedef} {ccname_iface_table_type(ccstructs_serialise_I)}
Type of methods table for the @iface{serialise} interface.  It has the following fields:

@table @code
@item ccname_iface_method_type(ccstructs_serialise_I, required_size) * required_size
Pointer to function implementing the @method{required_size} method.

@item ccname_iface_method_type(ccstructs_serialise_I, write) * write
Pointer to function implementing the @method{write} method.
@end table
@end deftp


@deftypefn {Function Prototype} size_t {ccname_iface_method_type(ccstructs_serialise_I, required_size)} (ccstructs_serialise_I const @var{I})
Type of functions implementing the @method{required_size} method.  Return the minimum number of
bytes needed to hold the serialisation of the source @struct{}.
@end deftypefn


@deftypefn {Function Prototype} ccmem_block_t {ccname_iface_method_type(ccstructs_serialise_I, write)} (cce_destination_t @var{L}, ccstructs_serialise_I const @var{I}, ccmem_block_t @var{B})
Type of functions implementing the @method{write} method.  Serialise the @struct{} to the block of
memory referenced by @var{B}.  Return a new block referencing the leftover memory right after the
serialised data.  If an error occurs: raise an exception violation by performing a non--local exit
to @var{L}.

@example
     memory block described by @var{B}
|-------------------------------------|
|++++++++++++++++++++++++|------------|
   memory filled with       leftover
   struct serialisation     memory
@end example
@end deftypefn

@c page
@node serialise operations
@section @iface{serialise} interface: operations


@deftypefun ccstructs_serialise_I {ccname_new(ccstructs_serialise_I)} (ccstructs_core_t const * @var{S}, ccname_iface_table_type(ccstructs_serialise_I) const * @var{M})
Interface constructor.  Return a new interface @struct{} given a pointer to the source @struct{} and
a pointer to the interface methods.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_serialise_self (ccstructs_serialise_I @var{I})
Return a pointer to the @struct{} to which the interface belongs.
@end deftypefun


@deftypefun size_t ccstructs_serialise_required_size (ccstructs_serialise_I @var{I})
Apply the method @method{required_size} to the given argument.
@end deftypefun


@deftypefun ccmem_block_t ccstructs_serialise_write (cce_destination_t @var{L}, ccstructs_serialise_I @var{I}, ccmem_block_t @var{B})
Apply the method @method{write} to the given arguments.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node deserialise typedefs
@section @iface{deserialise} interface: type definitions


@deftp {Struct Typedef} ccstructs_deserialise_I
Type of the @iface{deserialise} interface.  Instances of this type are meant to be handed by value
to function calls.
@end deftp


@deftp {Struct Typedef} {ccname_iface_table_type(ccstructs_deserialise_I)}
Type of methods table for the @iface{deserialise} interface.  It has the following fields:

@table @code
@item ccname_iface_method_type(ccstructs_deserialise_I, read) * read
Pointer to function implementing the @method{read} method.
@end table
@end deftp


@deftypefn {Function Prototype} ccmem_block_t {ccname_iface_method_type(ccstructs_deserialise_I, read)} (cce_destination_t @var{L}, ccstructs_deserialise_I const @var{I}, ccmem_block_t @var{B})
Type of functions implementing the @method{read} method. Dedeserialise the @struct{} from the
block of memory referenced by @var{B}.  Return a new block referencing the memory right after the
deserialised data.  If an error occurs: raise an exception violation by performing a non--local exit
to @var{L}.
@end deftypefn

@c page
@node deserialise operations
@section @iface{deserialise} interface: operations


@deftypefun ccstructs_deserialise_I {ccname_new(ccstructs_deserialise_I)} (ccstructs_core_t const * @var{S}, ccname_iface_table_type(ccstructs_deserialise_I) const * @var{M})
Interface constructor.  Return a new interface @struct{} given a pointer to the source @struct{} and
a pointer to the interface methods.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_deserialise_self (ccstructs_deserialise_I @var{I})
Return a pointer to the @struct{} to which the interface belongs.
@end deftypefun


@deftypefun ccmem_block_t ccstructs_deserialise_read (cce_destination_t @var{L}, ccstructs_deserialise_I @var{I}, ccmem_block_t @var{B})
Apply the method @method{read} to the given arguments.  If an error occurs: raise an exception
by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node pathname
@chapter The @iface{pathname} interface


The @iface{pathname} interface, represented by the type @objtype{ccstructs_pathname_I}, is meant to
be used in algorithm that need to operate on @posix{} pathname specifications without being tied to
a specific pathname internal representation; the only mandatory requirement is that the pathname has
an external representation as @asciiz{} string.

@menu
* pathname typedefs::           Type definitions.
* pathname api::                Programming interface.
* pathname simple::             Simple implementations.
@end menu

@c page
@node pathname typedefs
@section Type definitions for the @iface{pathname} interface


@deftp {Struct Typedef} ccstructs_pathname_I
Type of the @iface{pathname} interface.  Instances of this type are meant to be handed by value to
function calls.
@end deftp


@deftp {Struct Typedef} ccstructs_pathname_I_methods_t
Type of methods table for the @iface{pathname} interface.  It has the following fields:

@table @code
@item ccname_iface_method_type(ccstructs_pathname_I, dtor) * dtor
Pointer to function implementing the @method{dtor} method.

@item ccname_iface_method_type(ccstructs_pathname_I, asciiz) * asciiz
Pointer to function implementing the @method{asciiz} method.

@item ccname_iface_method_type(ccstructs_pathname_I, is_static) * is_static
Pointer to function implementing the @method{is_static} method.
@end table
@end deftp


@deftypefn {Function Prototype} ccstructs_dtor_I {ccname_iface_method_type(ccstructs_pathname_I, dtor)} (ccstructs_pathname_I @var{I})
Type of functions implementing the @method{dtor} method.  Return an instance of the
@objtype{ccstructs_dtor_I} interface that destroys the underlying pathname representation.
@end deftypefn


@deftypefn {Function Prototype} ccmem_asciiz_t {ccname_iface_method_type(ccstructs_pathname_I, asciiz)} (cce_destination_t @var{L}, ccstructs_pathname_I @var{I})
Type of functions implementing the @method{asciiz} method.  Return an instance of
@objtype{ccmem_asciiz_t} holding an @asciiz{} representation of the pathname.  If an error occurs
generating the representation: raise an exception by performing a non--local exit to @var{L}.
@end deftypefn


@deftypefn {Function Prototype} bool {ccname_iface_method_type(ccstructs_pathname_I, is_static)} (ccstructs_pathname_I @var{I})
Type of functions implementing the @method{is_static} method.  In general, the user of @var{I}
should make a copy of the @asciiz{} pathname representation, returned by the @method{asciiz} method,
if it needs to keep it independently from the extent (the lifetime) of @var{I}; but if this function
returns @ctrue{}: it can rely on the existence of the representation for the time it needs it.
@end deftypefn

@c page
@node pathname api
@section Programming interface for the @iface{pathname} interface


@deftypefun ccstructs_pathname_I {ccname_new(ccstructs_pathname_I)} (ccstructs_core_t const * @var{S}, ccname_iface_table_type(ccstructs_pathname_I) const * @var{M})
Interface constructor.  Return a new interface @struct{} given a pointer to the source @struct{} and
a pointer to the interface methods.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_pathname_self (ccstructs_pathname_I @var{I})
Return a pointer to the @struct{} to which the interface belongs.
@end deftypefun


@deftypefun ccstructs_dtor_I {ccname_iface_new(ccstructs_dtor_I, ccstructs_pathname_I)} (ccstructs_pathname_I @var{I})
Apply the method @method{dtor} to the interface instance.  Build and return an instance of the
interface @objtype{ccstructs_dtor_I} that we can use to destroy the underlying pathname
representation.
@end deftypefun


@deftypefun ccmem_asciiz_t ccstructs_pathname_asciiz (cce_destination_t @var{L}, ccstructs_pathname_I @var{I})
Apply the method @method{asciiz} to the interface instance.  Return an instance of
@objtype{ccmem_asciiz_t} holding an @asciiz{} representation of the pathname.  If an error occurs
generating the representation: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool ccstructs_pathname_is_static (ccstructs_pathname_I @var{I})
Apply the method @method{is_static} to the interface instance.
@end deftypefun

@c page
@node pathname simple
@section Simple implementations of a @iface{pathname} interface


@menu
* pathname simple typedefs::    Simple pathname: type definitions.
* pathname simple ctors::       Simple pathname: constructors.
* pathname simple ifaces::      Simple pathname: implemented interfaces.
* pathname simple samples::     Simple pathname: usage examples.
@end menu

@c page
@node pathname simple typedefs
@subsection Simple pathname: type definitions


@deftp {Struct Typedef} ccstructs_pathname_t
Type of simple file system pathname representation implemented by @value{PACKAGE}.
@end deftp

@c page
@node pathname simple ctors
@subsection Simple pathname: constructors


@subsubheading Constructors for embedded instances


@deftypefun void {ccname_init(ccstructs_pathname_t, from_asciiz)} (cce_destination_t @var{L}, ccstructs_pathname_t * @var{ptn}, ccmem_asciiz_t @var{rep})
Constructor function that initialises an already allocated @struct{} instance.  This function
initialises from an @asciiz{} representation.  @ccmemoryref{ascii zero, Zero terminated strings}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, from_ascii)} (cce_destination_t @var{L}, ccstructs_pathname_t * @var{ptn}, ccmem_ascii_t @var{rep})
Constructor function that initialises an already allocated @struct{} instance.  This function
initialises from an @ascii{} representation.  @ccmemoryref{ascii non-zero, Non--zero terminated
strings}.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, from_chars)} (cce_destination_t @var{L}, ccstructs_pathname_t * @var{ptn}, char const * @var{P})
Constructor function that initialises an already allocated @struct{} instance.  This function
initialises from a C pointer to an @asciiz{} representation.
@end deftypefun


@deftypefun void {ccname_init(ccstructs_pathname_t, deserialisable)} (ccstructs_pathname_t * @var{ptn})
Initialisation function that initialises an already allocated struct.  This function initialises in
such a way that it allows for both finalisation and mutation from deserialisation.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Constructors for standalone instances


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, from_asciiz)} (cce_destination_t @var{L}, ccmem_asciiz_t @var{rep})
Constructor function that allocates the @struct{} on the heap using the standard memory allocator
implemented by CCMemory.  This function initialises from an @asciiz{} representation.
@ccmemoryref{ascii zero, Zero terminated strings}.
@end deftypefun


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, from_ascii)} (cce_destination_t @var{L}, ccmem_ascii_t @var{rep})
Constructor function that allocates the @struct{} on the heap using the standard memory allocator
implemented by CCMemory.  This function initialises from an @ascii{} representation.
@ccmemoryref{ascii non-zero, Non--zero terminated strings}.
@end deftypefun


@deftypefun {ccstructs_pathname_t const *} {ccname_new(ccstructs_pathname_t, from_chars)} (cce_destination_t @var{L}, char const * @var{P})
Constructor function that allocates the @struct{} on the heap using the standard memory allocator
implemented by CCMemory.  This function initialises from a C pointer to an @asciiz{} representation.
@end deftypefun


@deftypefun {ccstructs_pathname_t *} {ccname_new(ccstructs_pathname_t, deserialisable)} (cce_destination_t @var{L})
Constructor function that allocates the @struct{} on the heap using the standard memory allocator
implemented by CCMemory.  This function initialises in such a way that it allows for both
finalisation and mutation from deserialisation.
@end deftypefun

@c page
@node pathname simple ifaces
@subsection Simple pathname: implemented interfaces


@deftypefun ccstructs_dtor_I {ccname_iface_new(ccstructs_dtor_I, ccstructs_pathname_t)} (ccstructs_pathname_t const * @var{ptn})
Interface constructor for @objtype{ccstructs_dtor_I} as implemented by
@objtype{ccstructs_pathname_t}.  The returned destructor interface will work for both embedded and
standalone instances of @objtype{ccstructs_pathname_t}.
@end deftypefun


@deftypefun ccstructs_pathname_I {ccname_iface_new(ccstructs_pathname_I, ccstructs_pathname_t)} (ccstructs_pathname_t const * @var{ptn})
Interface constructor for @objtype{ccstructs_pathname_I} as implemented by
@objtype{ccstructs_pathname_t}.
@end deftypefun


@deftypefun ccstructs_serialise_I {ccname_iface_new(ccstructs_serialise_I, ccstructs_pathname_t)} (ccstructs_pathname_t const * @var{ptn})
Constructor for a @objtype{ccstructs_serialise_I} interface that serialises an instance of
@objtype{ccstructs_pathname_t} into a memory block.
@end deftypefun


@deftypefun ccstructs_deserialise_I {ccname_iface_new(ccstructs_deserialise_I, ccstructs_pathname_t)} (ccstructs_pathname_t * @var{ptn})
Constructor for a @objtype{ccstructs_deserialise_I} interface that deserialises an instance of
@objtype{ccstructs_pathname_t} from a memory block.
@end deftypefun


@deftypefun ccstructs_dumpable_I {ccname_iface_new(ccstructs_dumpable_I, ccstructs_pathname_t)} (ccstructs_pathname_t const * @var{ptn})
Constructor for a @objtype{ccstructs_dumpable_I} interface that prints the a representation of the
underlying @objtype{ccstructs_pathname_t} on the @stderr{} stream.
@end deftypefun

@c page
@node pathname simple samples
@subsection Simple pathname: usage examples


Let's see how we can build a standalone instance of @objtype{ccstructs_pathname_t} using the
standard allocator implemented by CCMemory:

@example
char const *                  P = "/path/to/file.ext";
cce_location_t                L[1];
ccstructs_pathname_t const *  ptn;
ccstructs_clean_handler_t     ptn_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  ptn = ccname_new(ccstructs_pathname_t, from_chars)(L, P);
  ccstructs_clean_handler_init(L, ptn_H,
    ccname_iface_new(ccstructs_dtor_I, ccstructs_pathname_t)(ptn));

  ...
  cce_run_body_handlers(L);
@}
@end example

We can dump to @stderr{} a string representation of the instance with:

@example
ccstructs_dumpable_I  W =
  ccname_iface_new(ccstructs_dumpable_I, ccstructs_pathname_t)(ptn);

ccstructs_dumpable_dump(L, W);
@end example

We can create an interface @objtype{ccstructs_pathname_I} with:

@example
ccstructs_pathname_I I   =
  ccname_iface_new(ccstructs_pathname_I, ccstructs_pathname_t)(ptn);
ccmem_asciiz_t       rep = ccstructs_pathname_asciiz(L, I);
@end example

@noindent
and use the @asciiz{} representation @code{rep} as we see fit.

We can serialise the pathname with:

@example
ccstructs_serialise_I  IS =
  ccname_iface_new(ccstructs_serialise_I, ccstructs_pathname_t)(ptn);

/* Allocate memory for the serialisation. */
ccmem_block_t  M =
  ccmem_block_malloc_guarded(L, M_H, ccmem_standard_allocator,
    ccstructs_serialise_required_size(IS));

/* Serialise the struct. */
ccmem_block_t  M_leftover = ccstructs_serialise_write(L, IS, M);
@end example

@noindent
and we can deserialise a pathname instance from a memory block @code{M} with:

@example
ccmem_block_t           M = ...
ccmem_block_t           M_leftover;
ccstructs_pathname_t *  B;
ccstructs_deserialise_I ID;

B  = ccname_new(ccstructs_pathname_t, deserialisable)(L);
ID = ccname_iface_new(ccstructs_deserialise_I, ccstructs_pathname_t)(B);
M_leftover = ccstructs_deserialise_read(L, ID, M);
@end example

@c page
@node utils
@chapter Utility definitions


@defmac CCSTRUCTS_PC (@var{POINTER_TYPE}, @var{POINTER_NAME}, @var{EXPRESSION})
Preprocessor macro used to define pointer variables initialised with a cast expression.  It expands
to:

@example
POINTER_TYPE * POINTER_NAME = (POINTER_TYPE *) (EXPRESSION)
@end example

For example, the macro use:

@example
CCSTRUCTS_PC(ccstructs_descriptor_test_failure_t, C, _C);
@end example

@noindent
expands into:

@example
ccstructs_descriptor_test_failure_t * C = \
   (ccstructs_descriptor_test_failure_t *) (_C);
@end example
@end defmac


@defmac CCSTRUCTS_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  If the symbol
@code{__GNUC__} is defined, the expansion is:

@example
__attribute__((__unused__))
@end example

@noindent
otherwise the expansion is the empty string.
@end defmac

@c page
@node ccnames
@appendix Automatically generated @api{} names


The header file @file{ccnames.h} defines a set of macros that generate, at expansion time,
identifiers for functions and variables that have ``well known'' roles in the @api{} of the
CCLibraries projects.

@menu
* ccnames struct common::       Well known functions for @struct{} types.
* ccnames struct table::        Tables of methods for @struct{} types.
* ccnames iface::               Well known names for interface types.
@end menu

@c page
@node ccnames struct common
@appendixsec Well known functions for @struct{} types


The macros for ``well known functions'' define an @api{} for the basic operations upon a data
@struct{}.  The following macros are defined in the header file @file{ccnames.h}.


@defmac ccname_init (@var{STRUCT_TYPE})
@defmacx ccname_init (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
@api{} function @cfunc{init}.

Functions with this name are constructors for @struct{} instances allocated on the stack or embedded
into enclosing @struct{} instances.  They allocate all the asynchronous resources and initialise the
@struct{} fields.
@end defmac


@defmac ccname_final (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{final}.

Functions with this name are destructors for @struct{} instances allocated on the stack or embedded
into enclosing @struct{} instances.  They release all the asynchronous resources associated to the
@struct{} fields.
@end defmac


@defmac ccname_alloc (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{alloc}.

Functions of this type are memory allocators for @struct{} instances allocated on the heap.  They
might perform the allocation using the @api{} of the library CCMemory.
@end defmac


@defmac ccname_release (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{release}.

Functions of this type are memory releasers for @struct{} instances allocated on the heap.  They
might perform the release using the @api{} of the library CCMemory.
@end defmac


@defmac ccname_new (@var{STRUCT_TYPE})
@defmacx ccname_new (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
@api{} function @cfunc{new}.

Functions with this name are constructors for @struct{} instances allocated on the heap.  The memory
allocation is performed by calling the @cfunc{alloc} function.  The initialisation of the fields is
performed by calling the @cfunc{init} function.
@end defmac


@defmac ccname_delete (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{delete}.

Functions with this name are destructors for @struct{} instances allocated on the heap.  The
finalisation of the fields is performed by calling the @cfunc{final} function.  The memory release
is performed by calling the @cfunc{release} function.
@end defmac


An example of common function implementation for @struct{} types:

@smallexample
#include <ccexceptions.h>
#include <ccmemory.h>
#include <ccnames.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef struct my_coords_t      my_coords_t;

struct my_coords_t @{
  double        X;
  double        Y;
@};

void
ccname_init(my_coords_t, rec) (my_coords_t * S, double X, double Y)
@{
  S->X = X;
  S->Y = Y;
@}

void
ccname_init(my_coords_t, pol) (my_coords_t * S, double RHO, double THETA)
@{
  S->X = RHO * cos(THETA);
  S->Y = RHO * sin(THETA);
@}

void
ccname_final(my_coords_t) (my_coords_t * S)
@{
@}

static my_coords_t *
ccname_alloc(my_coords_t) (cce_destination_t L)
@{
  return (my_coords_t *)ccmem_std_malloc(L, sizeof(my_coords_t));
@}

static void
ccname_release(my_coords_t) (my_coords_t * S)
@{
  ccmem_std_free(S);
@}

my_coords_t *
ccname_new(my_coords_t, rec) (cce_destination_t L, double X, double Y)
@{
  my_coords_t * S = ccname_alloc(my_coords_t)(L);

  ccname_init(my_coords_t, rec)(S, X, Y);
  return S;
@}

my_coords_t *
ccname_new(my_coords_t, pol) (cce_destination_t L, double RHO, double THETA)
@{
  my_coords_t * S = ccname_alloc(my_coords_t)(L);

  ccname_init(my_coords_t, pol)(S, RHO, THETA);
  return S;
@}

void
ccname_delete(my_coords_t) (my_coords_t * S)
@{
  ccname_final(my_coords_t)(S);
  ccname_release(my_coords_t)(S);
@}

int
main (void)
@{
  cce_location_t        L[1];
  my_coords_t *         S;

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    S = ccname_new(my_coords_t, rec)(L, 1.0, 2.0);

    printf("X=%f, Y=%f\n", S->X, S->Y);
    ccname_delete(my_coords_t)(S);
  @}
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node ccnames struct table
@appendixsec Tables of methods for @struct{} types


The macros for the ``table of methods known functions'' define an @api{} to implement a table of
methods in a data @struct{}: every instance of the @struct{} type is meant to hold a pointer to a
statically allocated @struct{} which in turn holds pointers to method functions.  The following
macros are defined in the header file @file{ccnames.h}.


@defmac ccname_table_type (@var{STRUCT_TYPE})
@defmacx ccname_table_type (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
methods table type for the @struct{} type.
@end defmac


@defmac ccname_table (@var{STRUCT_TYPE})
@defmacx ccname_table (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
methods table for the @struct{} type.
@end defmac


@defmac ccname_method_type (@var{STRUCT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given a @struct{} type name, an optional variant specification, and a method name: expand into the
type name of that variant of the method function for the @struct{} type.
@end defmac


@defmac ccname_method (@var{STRUCT_TYPE}, @var{METHOD_NAME})
@defmacx ccname_method (@var{STRUCT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given a @struct{} type name, an optional variant specification, and a method name: expand into the
name of that variant of the method for that @struct{} type.
@end defmac


An example of methods table implementation for @struct{} types:

@smallexample
#include <ccexceptions.h>
#include <ccnames.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct my_coords_t                      my_coords_t;
typedef struct ccname_table_type(my_coords_t)   ccname_table_type(my_coords_t);

typedef void ccname_method_type(my_coords_t, print) (my_coords_t * S, FILE * stream);

struct my_coords_t @{
  ccname_table_type(my_coords_t) const * methods;
  double        X;
  double        Y;
@};

struct ccname_table_type(my_coords_t) @{
  ccname_method_type(my_coords_t, print) * print_rec;
  ccname_method_type(my_coords_t, print) * print_pol;
@};

static void
ccname_method(my_coords_t, print_rec) (my_coords_t * S, FILE * stream)
@{
  fprintf(stream, "X=%f, Y=%f\n", S->X, S->Y);
@}

static void
ccname_method(my_coords_t, print_pol) (my_coords_t * S, FILE * stream)
@{
  double        RHO   = hypot(S->X, S->Y);
  double        THETA = atan2(S->Y, S->X);

  fprintf(stream, "RHO=%f, THETA=%f\n", RHO, THETA);
@}

static ccname_table_type(my_coords_t) const ccname_table(my_coords_t) = @{
  .print_rec    = ccname_method(my_coords_t, print_rec),
  .print_pol    = ccname_method(my_coords_t, print_pol)
@};

void
ccname_init(my_coords_t, rec) (my_coords_t * S, double X, double Y)
@{
  S->methods = &ccname_table(my_coords_t);
  S->X = X;
  S->Y = Y;
@}

void
ccname_init(my_coords_t, pol) (my_coords_t * S, double RHO, double THETA)
@{
  S->methods = &ccname_table(my_coords_t);
  S->X = RHO * cos(THETA);
  S->Y = RHO * sin(THETA);
@}
@end smallexample

@c page
@node ccnames iface
@appendixsec Well known names for interface types.


The macros for ``well known interface functions'' define an @api{} to implement interface @struct{}
types; an interface is a set of operations we can apply to a data @struct{}; multiple data @struct{}
types can implement multiple interfaces.  The following macros are defined in the header file
@file{ccnames.h}.


@defmac ccname_iface_new_type (@var{IFACE_TYPE})
@defmacx ccname_iface_new_type (@var{IFACE_TYPE}, @var{STRUCT_TYPE})
@defmacx ccname_iface_new_type (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT})
Given an interface type name, an optional struct name and an optional variant specification: expand
into the function type name of interface implementation constructors.  Constructors of such type
must build instances of @var{IFACE_TYPE} as implemented by @var{STRUCT_TYPE}, as specified for the
variant @var{VARIANT}.
@end defmac


@defmac ccname_iface_new (@var{IFACE_TYPE}, @var{STRUCT_TYPE})
@defmacx ccname_iface_new (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT})
Given an interface type name, a struct type name, an optional variant specification: expand into the
name of the @api{} function @cfunc{new} that instantiates that variant of the interface for the
@struct{}.
@end defmac


@defmac ccname_iface_table_type (@var{IFACE_TYPE})
@defmacx ccname_iface_table_type (@var{IFACE_TYPE}, @var{VARIANT})
Given an interface type name and an optional variant specification: expand into the name of the
methods table type for the interface type.
@end defmac


@defmac ccname_iface_table (@var{IFACE_TYPE}, @var{STRUCT_TYPE})
@defmacx ccname_iface_table (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT})
Given an interface type name, a struct type name, and an optional variant specification: expand into
the name of the methods table for that variant of the interface implementation for the @struct{}
type.
@end defmac


@defmac ccname_iface_method_type (@var{IFACE_TYPE}, @var{METHOD_NAME})
@defmacx ccname_iface_method_type (@var{IFACE_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given an interface type name, an optional variant specification, and a method name: expand into the
type name of the method function for that variant of the interface implementation.
@end defmac


@defmac ccname_iface_method (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{METHOD_NAME})
@defmacx ccname_iface_method (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given an interface type name, a struct type name, an optional variant specification, and a method
name: expand into the name of the method function for that variant of the interface implementation
for the struct type.
@end defmac


Let's say we have this @struct{} definition:

@smallexample
typedef struct my_coords_t      my_coords_t;

struct my_coords_t @{
  double        X;
  double        Y;
@};
@end smallexample

@noindent
and we want to define an interface type @objtype{my_printable_I} to print the @struct{} on a
standard stream, both in rectangular and polar forms.

Every interface must have a @struct{} acting as table of pointers to functions, whose functions
implements the interface methods.  The interface @struct{} type is unique, the methods table
@struct{} type is unique; for every data @struct{} that implements the interface: we need a methods
table and an interface constructor.

The interface @struct{} type and the methods table @struct{} type are defined as follows:

@smallexample
typedef struct my_printable_I   my_printable_I;
typedef struct ccname_iface_table_type(my_printable_I) \
  ccname_iface_table_type(my_printable_I);

struct my_printable_I @{
  ccname_iface_table_type(my_printable_I)  const * methods;
  ccstructs_core_t                         const * self;
@};

typedef void ccname_iface_method_type(my_printable_I, print) \
  (my_printable_I I, FILE * stream);

struct ccname_iface_table_type(my_printable_I) @{
  ccname_iface_method_type(my_printable_I, print) * print_rec;
  ccname_iface_method_type(my_printable_I, print) * print_pol;
@};
@end smallexample

The @objtype{my_printable_I} interface @api{} is defined as follows:

@smallexample
my_printable_I
my_printable_new (ccstructs_core_t const * S,
                  ccname_iface_table_type(my_printable_I) const * M)
@{
  my_printable_I        I = @{
    .methods    = M,
    .self       = S
  @};
  return I;
@}

ccstructs_core_t const *
my_printable_self (my_printable_I I)
@{
  return I.self;
@}

void
my_printable_print_rec (my_printable_I I, FILE * stream)
@{
  I.methods->print_rec(I, stream);
@}

void
my_printable_print_pol (my_printable_I I, FILE * stream)
@{
  I.methods->print_pol(I, stream);
@}
@end smallexample

The implementation of @objtype{my_printable_I} for the data @struct{} @objtype{my_coords_t} is
defined as follows:

@smallexample
static void
ccname_iface_method(my_printable_I, my_coords_t, print_rec) (my_printable_I I, FILE * stream)
@{
  CCSTRUCTS_PC(my_coords_t, S, my_printable_self(I));

  fprintf(stream, "X=%f, Y=%f\n", S->X, S->Y);
@}

static void
ccname_iface_method(my_printable_I, my_coords_t, print_pol) (my_printable_I I, FILE * stream)
@{
  CCSTRUCTS_PC(my_coords_t, S, my_printable_self(I));
  double        RHO   = hypot(S->X, S->Y);
  double        THETA = atan2(S->Y, S->X);

  fprintf(stream, "RHO=%f, THETA=%f\n", RHO, THETA);
@}

static ccname_iface_table_type(my_printable_I) const ccname_iface_table(my_printable_I, my_coords_t) = @{
  .print_rec    = ccname_iface_method(my_printable_I, my_coords_t, print_rec),
  .print_pol    = ccname_iface_method(my_printable_I, my_coords_t, print_pol)
@};

my_printable_I
ccname_iface_new(my_printable_I, my_coords_t) (my_coords_t * S)
@{
  return my_printable_new(ccstructs_core(S), &ccname_iface_table(my_printable_I, my_coords_t));
@}
@end smallexample

We can use the interface as follows:

@smallexample
int
main (void)
@{
  cce_location_t        L[1];
  my_coords_t *         S;
  my_printable_I        I;

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    S = ccname_new(my_coords_t, rec)(L, 1.0, 2.0);
    I = ccname_iface_new(my_printable_I, my_coords_t)(S);

    my_printable_print_rec(I, stdout);
    my_printable_print_pol(I, stdout);
    ccname_delete(my_coords_t)(S);
  @}
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
the package CCExceptions is available at:

@center @url{https://github.com/marcomaggi/ccexceptions/}

@noindent
the package CCMemory is available at:

@center @url{https://github.com/marcomaggi/ccmemory/}

@noindent
the package CCTests is available at:

@center @url{https://github.com/marcomaggi/cctests/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

