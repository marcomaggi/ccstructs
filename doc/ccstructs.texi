\input texinfo.tex
@c %**start of header
@setfilename ccstructs.info
@settitle CCStructs
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@macro method{NAME}
@cfunc{\NAME\}
@end macro

@macro iface{NAME}
@code{\NAME\}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCStructs

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCStructs

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccstructs

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2018, 2019

@c ------------------------------------------------------------

@set CCEXCEPTIONS_VERSION       0.8.0
@set CCMEMORY_VERSION           0.2.1
@set CCTESTS_VERSION            0.3.0

@set GITHUB_URL                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing common interface for C structs.

This package supports @posix{} platforms.  This package depends on the packages: CCExceptions, at
least version @value{CCEXCEPTIONS_VERSION}; CCMemory, at least version @value{CCMEMORY_VERSION}.  To
run the test suite: this package depends upon the package CCTests, at least version
@value{CCTESTS_VERSION}.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccstructs: (ccstructs).       Common interfaces for C structs.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* core::                        Core type definitions.
* dtor::                        The @iface{dtor} interface.
* writable::                    The @emph{writable} interface.
* serialisable::                The @emph{serialisable} interface.
* pathname::                    The @emph{pathname} interface.
* utils::                       Utility definitions.

Appendices

* ccnames::                     Automatically generated @api{} names.
* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing common interfaces for C structs.

This package supports @posix{} platforms.  This package depends on the packages: CCExceptions, at
least version @value{CCEXCEPTIONS_VERSION}; CCMemory, at least version @value{CCMEMORY_VERSION}.  To
run the test suite: this package depends upon the package CCTests, at least version
@value{CCTESTS_VERSION}.

@value{PACKAGE} installs the header files @file{ccstructs.h} and @file{ccnames.h}.  All the function
names in the @api{} are prefixed with @code{ccstructs_}; all the preprocessor symbol names are
prefixed with @code{CCSTRUCTS_}; all the type names are prefixed with @code{ccstructs_} and suffixed
with @code{_t} or @code{_I}.

@menu
* overview linking::            Linking code with the library.
* overview examples::           Implementation examples.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCSTRUCTS],[ccstructs >= 0.1.0])
@end example

@noindent
which will set the variables @code{CCSTRUCTS_LIBS} and @code{CCSTRUCTS_CFLAGS}.  To avoid
problems with @command{pkg-config}, we need to remember that:

@itemize
@item
The macro file defining @code{PKG_CHECK_MODULES} is installed by the package @code{pkg-config}; such
file usually is in one of the locations:

@center @file{/usr/share/aclocal/pkg.m4}
@center @file{/usr/local/share/aclocal/pkg.m4}

@item
The macro file is located by @command{aclocal}, which in turn is installed by the package @gnu{}
Automake; @command{aclocal} is used by @command{autoreconf}.  We must make sure that
@command{aclocal} finds the installed macro files; for this purpose we can use the environment
variable @env{ACLOCAL_PATH}; under a Bourne shell we can do this with:

@example
export ACLOCAL_PATH=/usr/local/share/aclocal:/usr/share/aclocal
@end example
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccstructs],[ccstructs_version_string],,
  [AC_MSG_FAILURE([test for CCStructs library failed])])
AC_CHECK_HEADERS([ccstructs.h],,
  [AC_MSG_FAILURE([test for CCStructs header failed])])
@end example

@c page
@node overview examples
@section Implementation examples


The source distribution comes with some implementation examples under the directory @file{examples}.
This code is meant to be a starting point when implementing the interfaces defined by
@value{PACKAGE}: we should copy it and adapt it to our needs.

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccstructs_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing
the interface version number.
@end deftypefun


@deftypefun int ccstructs_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccstructs_version_interface_revision (void)
Return an integer representing the library interface current revision
number.
@end deftypefun


@deftypefun int ccstructs_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node core
@chapter Core type definitions


@value{PACKAGE} offers an @api{} to handle @struct{} values.  The library cannot reference the
concrete types of @struct{} the client libraries will use, so it just defines a placeholder for
them.


@deftp {Struct Typedef} ccstructs_core_t
Type of @struct{} values used as argument to @value{PACKAGE} functions.  This is just a forward type
declaration: there is no actual declaration of this type.
@end deftp


When using this type we need to explicitly cast a pointer to client @struct{} values to a pointer to
@objtype{ccstruct_core_t}.  For example, when defining a constructor for the @emph{writable}
interface:

@example
ccstructs_writable_I
spiffy_new_I_writable (spiffy_t * S)
@{
  return ccstructs_new_writable(ccstructs_core(S),
     &spiffy_writable_I_methods);
@}
@end example


@deftypefun {ccstructs_core_t *} ccstructs_core (void const * @var{S})
Cast the pointer @var{S} to @code{ccstructs_core_t *}.
@end deftypefun

@c page
@node dtor
@chapter The @iface{dtor} interface


The @iface{dtor} interface provides a uniform way to call a @struct{} destructors.  The best way to
use the @iface{dtor} interface is through the exception handlers @api{}, @ref{dtor handlers,
Exception handlers}.

@menu
* dtor typedefs::              @iface{dtor} interface: type definitions.
* dtor operations::            @iface{dtor} interface: operations.
* dtor handlers::              Exception handlers.
* dtor sample empty::          Example of @iface{dtor} interface
                               with empty @method{delete} method.
* dtor sample non-empty::      Example of @iface{dtor} interface
                               with non-empty @method{delete} method.
@end menu

@c page
@node dtor typedefs
@section @iface{dtor} interface: type definitions


@deftp {Struct Typedef} ccstructs_dtor_I
Type of the @iface{dtor} interface @struct{}.  Instances of this type are meant to be handed by
value to function calls.
@end deftp


@deftp {Struct Typedef} ccstructs_dtor_I_methods_t
Type of methods table for the @iface{dtor} interface.  It has the following fields:

@table @code
@item ccstructs_dtor_I_delete_fun_t * delete
Pointer to function implementing the @method{delete} method.  This method releases the memory
allocated for the @struct{} itself, if needed.

@item ccstructs_dtor_I_final_fun_t * final
Pointer to function implementing the @method{final} method.  Release all the asynchronous resources
owned by the fields of the @struct{}, if any.  The @struct{} itself is left alone.
@end table
@end deftp


@deftypefn {Function Prototype} void ccstructs_dtor_I_delete_fun_t (ccstructs_dtor_I @var{I})
Type of functions implementing the @method{delete} method.  This method releases the memory allocated
for the @struct{} itself, if needed; if a @struct{} is allocated on the stack or embedded into an
enclosing @struct{}: this method should do nothing.
@end deftypefn


@deftypefn {Function Prototype} void ccstructs_dtor_I_final_fun_t (ccstructs_dtor_I @var{I})
Type of functions implementing the @method{final} method.  Release all the asynchronous resources
owned by the fields of the @struct{}, if any.  The @struct{} itself is left alone.
@end deftypefn


@deftypefn {Function Prototype} ccstructs_dtor_I ccstructs_new_dtor_fun_t (ccstructs_core_t const * @var{self})
Type of functions implementing the constructor for @iface{dtor} interfaces.
@end deftypefn

@c page
@node dtor operations
@section @iface{dtor} interface: operations


@deftypefun ccstructs_dtor_I ccstructs_new_dtor (ccstructs_core_t const * @var{S}, ccstructs_dtor_I_methods_t const * @var{M})
Build and return a new @iface{dtor} interface @struct{}.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_dtor_self (ccstructs_dtor_I @var{I})
Return a pointer to the subject @struct{} to which the interface belongs.
@end deftypefun


@deftypefun void ccstructs_dtor_final (ccstructs_dtor_I @var{I})
Apply the @method{final} method to the subject @struct{}.  This function is the faster destructor
for a @struct{} allocated on the stack or embedded in an enclosing @struct{}; calling the
@method{delete} method is slower.
@end deftypefun


@deftypefun void ccstructs_dtor_delete (ccstructs_dtor_I @var{I})
Apply the @method{final} method to the subject @struct{}, then apply the @method{delete} method to
the subject @struct{}.  This function is always a correct destructor for a @struct{}.
@end deftypefun

@c page
@node dtor handlers
@section Exception handlers


The best way to use the @iface{dtor} interface is through the exception handlers @api{}.


@deftp {Struct Typedef} ccstructs_clean_handler_t
Type of @struct{} usable has clean handler with the facilities of the CCExceptions library.
@end deftp


@deftp {Struct Typedef} ccstructs_error_handler_t
Type of @struct{} usable has error handler with the facilities of the CCExceptions library.
@end deftp


@deftypefun void ccstructs_clean_handler_init (cce_destination_t @var{L}, ccstructs_clean_handler_t * @var{H}, ccstructs_dtor_I @var{I})
Initialise the exception handler @var{H} to use the @method{delete} method of the @iface{dtor}
interface @var{I}, in the context of the location @var{L}.
@end deftypefun


@deftypefun void ccstructs_error_handler_init (cce_destination_t @var{L}, ccstructs_error_handler_t * @var{H}, ccstructs_dtor_I @var{I})
Initialise the exception handler @var{H} to use the @method{delete} method of the @iface{dtor}
interface @var{I}, in the context of the location @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccstructs_handler_init (cce_destination_t @var{L}, @var{H}, ccstructs_dtor_I @var{I})
Initialise the exception handler @var{H} to use the @method{delete} method of the @iface{dtor}
interface @var{I}, in the context of the location @var{L}.  If @var{H} is a pointer of type:

@table @code
@item ccstructs_clean_handler_t
The macro use expands to a call to @cfunc{ccstructs_clean_handler_init}.

@item ccstructs_error_handler_t
The macro use expands to a call to @cfunc{ccstructs_error_handler_init}.
@end table
@end deftypefn


As example, let's consider this @struct{} definition:

@example
typedef struct two_t    two_t;

struct two_t @{
  void *  pointer;
@};
@end example

@noindent
for it we define a constructor as follows:

@example
two_t *
two_new (cce_destination_t upper_L, int init)
@{
  cce_location_t        L[1];
  cce_error_handler_t   S_H[1];
  two_t *               S;

  if (cce_location(L)) @{
    cce_run_catch_handlers_raise(L, upper_L);
  @} else @{
    S           = cce_sys_malloc_guarded(L, S_H, sizeof(two_t));
    S->pointer  = cce_sys_malloc(L, 256);
    memset(S->pointer, init, 256);
    cce_run_body_handlers(L);
  @}
  return S;
@}
@end example

@noindent
we can implement the @iface{dtor} interface as follows:

@example
static void
two_dtor_method_delete (ccstructs_dtor_I I)
@{
  CCSTRUCTS_PC(two_t, S, ccstructs_dtor_self(I));

  free(S);
@}

static void
two_dtor_method_final (ccstructs_dtor_I I)
@{
  CCSTRUCTS_PC(two_t, S, ccstructs_dtor_self(I));

  free(S->pointer);
@}

static ccstructs_dtor_I_methods_t const two_dtor_I_methods = @{
  .delete       = two_dtor_method_delete,
  .final        = two_dtor_method_final
@};

ccstructs_dtor_I
two_new_I_dtor (two_t * S)
@{
  return ccstructs_new_dtor(ccstructs_core(S), &two_dtor_I_methods);
@}
@end example

@noindent
and we can use it with the exception handlers as follows:

@example
cce_location_t                L[1];
ccstructs_clean_handler_t     I_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  two_t * S = two_new(L, 123);
  ccstructs_handler_init(L, I_H, two_new_I_dtor(S));

  cce_run_body_handlers(L);
@}
@end example

Now we can easily define a guarded constructor:

@example
two_t *
two_new_guarded_clean (cce_destination_t L,
                       ccstructs_clean_handler_t * I_H, int init)
@{
  two_t * S = two_new(L, init);
  ccstructs_handler_init(L, I_H, two_new_I_dtor(S));
  return S;
@}

two_t *
two_new_guarded_error (cce_destination_t L,
                       ccstructs_error_handler_t * I_H, int init)
@{
  two_t * S = two_new(L, init);
  ccstructs_handler_init(L, I_H, two_new_I_dtor(S));
  return S;
@}

#define two_new_guarded(L,I_H,S)                           \
  _Generic((I_H),                                          \
    ccstructs_clean_handler_t *: two_new_guarded_clean,    \
    ccstructs_error_handler_t *: two_new_guarded_error)(L,I_H,S)
@end example

@c page
@node dtor sample empty
@section Example of @iface{dtor} interface with empty @method{delete} method


Let's consider a @struct{} with the following definition:

@example
typedef struct one_t    one_t;

struct one_t @{
  void *  pointer;
@};
@end example

@noindent
we assume instances of this type are always allocated on the stack or embedded in an enclosing
@struct{}.  We can implement the @emph{destructor} interface as follows:

@example
static void
one_dtor_method_delete (ccstructs_dtor_I I)
@{
@}

static void
one_dtor_method_final (ccstructs_dtor_I I)
@{
  CCSTRUCTS_PC(one_t, S, ccstructs_dtor_self(I));

  ccmem_free(ccmem_standard_allocator, S->pointer);
@}

static ccstructs_dtor_I_methods_t const one_dtor_I_methods = @{
  .delete       = one_dtor_method_delete,
  .final        = one_dtor_method_final
@};

ccstructs_dtor_I
one_new_I_dtor (one_t * S)
@{
  return ccstructs_new_dtor(ccstructs_core(S), &one_dtor_I_methods);
@}
@end example

@noindent
and we can use the interface as follows:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  one_t       S = @{
    .pointer  = ccmem_malloc(L, ccmem_standard_allocator, 256)
  @};
  ccstructs_dtor_I   I = one_new_I_dtor(&S);

  ...
  ccstructs_dtor_delete(I);
  cce_run_body_handlers(L);
@}
@end example

@c page
@node dtor sample non-empty
@section Example of @iface{dtor} interface with non--empty @method{delete} method


Let's consider a @struct{} with the following definition:

@example
typedef struct two_t    two_t;

struct two_t @{
  void *  pointer;
@};
@end example

@noindent
we assume instances of this type are always allocated on the heap.  We can implement the
@emph{destructor} interface as follows:

@example
static void
two_dtor_method_delete (ccstructs_dtor_I I)
@{
  CCSTRUCTS_PC(two_t, S, ccstructs_dtor_self(I));

  ccmem_free(ccmem_standard_allocator, S);
@}

static void
two_dtor_method_final (ccstructs_dtor_I I)
@{
  CCSTRUCTS_PC(two_t, S, ccstructs_dtor_self(I));

  ccmem_free(ccmem_standard_allocator, S->pointer);
@}

static ccstructs_dtor_I_methods_t const two_dtor_I_methods = @{
  .delete       = two_dtor_method_delete,
  .final        = two_dtor_method_final
@};

ccstructs_dtor_I
two_new_I_dtor (two_t * S)
@{
  return ccstructs_new_dtor(ccstructs_core(S), &two_dtor_I_methods);
@}
@end example

@noindent
and we can use the interface as follows:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  two_t * S = ccmem_malloc(L, ccmem_standard_allocator, sizeof(two_t));
  S->pointer = ccmem_malloc(L, ccmem_standard_allocator, 256)
  ccstructs_dtor_I   I = two_new_I_dtor(&S);

  ...
  ccstructs_dtor_delete(I);
  cce_run_body_handlers(L);
@}
@end example

@c page
@node writable
@chapter The @emph{writable} interface


The @emph{writable} interface, represented by the type @objtype{ccstructs_writable_I}, is meant to
write an object to some output channel, mostly for inspection and debugging purposes; this interface
is neither for presentation to the end user of a program, nor for memorisation on a storage device.


@deftp {Struct Typedef} ccstructs_writable_I
Type of the @emph{writable} interface.  Instances of this type are meant to be handed by value to
function calls.
@end deftp


@deftp {Struct Typedef} ccstructs_writable_I_methods_t
Type of methods table for the @emph{writable} interface.  It has the following fields:

@table @code
@item ccstructs_writable_I_write_fun_t * write
Pointer to function implementing the @method{write} method.
@end table
@end deftp


@deftypefn {Function Prototype} void ccstructs_writable_I_write_fun_t (cce_destination_t @var{L}, ccstructs_writable_I @var{I})
Type of functions implementing the @method{write} method.  Functions of this type write a
representation of the object to an output channel; it is responsibility of this method to select
which output channel to use.  If an error occurs: raise an exception by performing a non--local exit
to @var{L}.
@end deftypefn


@deftypefun ccstructs_writable_I ccstructs_new_writable (ccstructs_core_t * @var{S}, ccstructs_writable_I_methods_t const * @var{M})
Interface constructor.  Return a new interface @struct{} given a pointer to the source @struct{} and
a pointer to the interface methods.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_writable_self (ccstructs_writable_I @var{I})
Return a pointer to the @struct{} to which the interface belongs.
@end deftypefun


@deftypefun void ccstructs_writable_write (cce_destination_t @var{L}, ccstructs_writable_I @var{I})
Apply the method @method{write} to the @struct{}.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun


Let's say we have this @struct{} definition:

@example
typedef struct spiffy_t        spiffy_t;

struct spiffy_t @{
  int   alpha;
  int   beta;
@};
@end example

@noindent
we can implement a @emph{writable} interface as follows:

@smallexample
void
spiffy_write_method (cce_destination_t L, ccstructs_writable_I I)
@{
  CCSTRUCTS_PC(spiffy_t, S, I.self);
  int   rv;

  errno = 0;
  rv = fprintf(stderr, "spiffy_t: alpha=%d, beta=%d\n", S->alpha, S->beta);
  if (0 > rv) @{
    cce_raise(L, cce_condition_new_errno_clear());
  @}
@}

ccstructs_writable_I_methods_t const spiffy_writable_I_methods = @{
  .write = spiffy_write_method
@};

ccstructs_writable_I
spiffy_new_I_writable (spiffy_t * S)
@{
  return ccstructs_new_writable(ccstructs_core(S),
            &spiffy_writable_I_methods);
@}
@end smallexample

@noindent
then we can use the interface as follows:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  spiffy_t   S = @{
    .alpha    = 1,
    .beta     = 2
  @};
  ccstructs_writable_I  I = spiffy_new_I_writable(&S);

  ccstructs_writable_write(L, I);
  cce_run_body_handlers(L);
@}
@end example

@c page
@node serialisable
@chapter The @emph{serialisable} interface


The @emph{serialisable} interface, represented by the type @objtype{ccstructs_serialisable_I},
allows us to serialise a @struct{} into a destination and deserialise it back into a @struct{}.

@c ------------------------------------------------------------------------

@subsubheading Type definitions


@deftp {Struct Typedef} ccstructs_serialisable_I
Type of the @emph{serialisable} interface.  Instances of this type are meant to be handed by value
to function calls.
@end deftp


@deftp {Struct Typedef} ccstructs_serialisable_I_methods_t
Type of methods table for the @emph{serialisable} interface.  It has the following fields:

@table @code
@item ccstructs_serialisable_I_minimum_size_fun_t * minimum_size
Pointer to function implementing the @method{minimum_size} method.  This method returns the minimum
number of bytes needed to hold the serialisation of the source @struct{}.

@item ccstructs_serialisable_I_to_block_fun_t * to_block
Pointer to function implementing the @method{to_block} method.  This method serialises the @struct{}
to a block of memory.

@item ccstructs_serialisable_I_from_block_fun_t * from_block
Pointer to function implementing the @method{from_block} method.  This method deserialises the
@struct{} from a block of memory.
@end table
@end deftp


@deftypefn {Function Prototype} size_t ccstructs_serialisable_I_minimum_size_fun_t (ccstructs_serialisable_I const @var{I})
Type of functions implementing the @method{minimum_size} method.  Return the minimum number of bytes
needed to hold the serialisation of the source @struct{}.
@end deftypefn


@deftypefn {Function Prototype} ccmem_block_t ccstructs_serialisable_I_to_block_fun_t (cce_destination_t @var{L}, ccstructs_serialisable_I const @var{I}, ccmem_block_t @var{B})
Type of functions implementing the @method{to_block} method.  Serialise the @struct{} to the block of
memory referenced by @var{B}.  Return a new block referencing the memory right after the serialised
data.  If an error occurs: raise an exception violation by performing a non--local exit to @var{L}.
@end deftypefn


@deftypefn {Function Prototype} ccmem_block_t ccstructs_serialisable_I_from_block_fun_t (cce_destination_t @var{L}, ccstructs_serialisable_I const @var{I}, ccmem_block_t @var{B})
Type of functions implementing the @method{from_block} method. Deserialise the @struct{} from the
block of memory referenced by @var{B}.  Return a new block referencing the memory right after the
serialised data.  If an error occurs: raise an exception violation by performing a non--local exit
to @var{L}.
@end deftypefn

@c ------------------------------------------------------------------------

@subsubheading Programming interface


@deftypefun ccstructs_serialisable_I ccstructs_new_serialisable (ccstructs_core_t * @var{S}, ccstructs_serialisable_I_methods_t const * @var{M})
Interface constructor.  Return a new interface @struct{} given a pointer to the source @struct{} and
a pointer to the interface methods.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_serialisable_self (ccstructs_serialisable_I const @var{I})
Return a pointer to the @struct{} to which the interface belongs.
@end deftypefun


@deftypefun size_t ccstructs_serialisable_minimum_size (ccstructs_serialisable_I const @var{I})
Apply the method @method{minimum_size} to the given argument.
@end deftypefun


@deftypefun ccmem_block_t ccstructs_serialisable_to_block (cce_destination_t @var{L}, ccstructs_serialisable_I const @var{I}, ccmem_block_t @var{B})
Apply the method @method{to_block} to the given arguments.  If an error occurs: raise an exception
by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun ccmem_block_t ccstructs_serialisable_from_block (cce_destination_t @var{L}, ccstructs_serialisable_I const @var{I}, ccmem_block_t @var{B})
Apply the method @method{from_block} to the given arguments.  If an error occurs: raise an exception
by performing a non--local exit to @var{L}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Example


Let's say we have this @struct{} definition:

@example
typedef struct spiffy_t        spiffy_t;

struct spiffy_t @{
  bool  alpha;
  bool  beta;
@};
@end example

@noindent
we can implement a @emph{serialisable} interface as follows:

@smallexample
typedef struct serialised_spiffy_t  serialised_spiffy_t;

struct serialised_spiffy_t @{
  bool  alpha;
  bool  beta;
@};

static size_t
spiffy_serialisable_I_minimum_size_method (ccstructs_serialisable_I I)
@{
  return sizeof(serialised_spiffy_t);
@}

static ccmem_block_t
spiffy_serialisable_I_to_block_method (cce_destination_t L,
   ccstructs_serialisable_I I, ccmem_block_t B)
@{
  CCSTRUCTS_PC(spiffy_t const, S, ccstructs_serialisable_self(I));
  CCSTRUCTS_PC(serialised_spiffy_t, W, B.ptr);
  ccmem_block_t N = @{
    .ptr        = B.ptr + sizeof(serialised_spiffy_t),
    .len        = B.len - sizeof(serialised_spiffy_t)
  @};

  W->alpha      = S->alpha;
  W->beta       = S->beta;
  return N;
@}

static ccmem_block_t
spiffy_serialisable_I_from_block_method (cce_destination_t L,
   ccstructs_serialisable_I I, ccmem_block_t B)
@{
  CCSTRUCTS_PC(spiffy_t, S, ccstructs_serialisable_self(I));
  CCSTRUCTS_PC(serialised_spiffy_t const, W, B.ptr);
  ccmem_block_t N = @{
    .ptr        = B.ptr + sizeof(serialised_spiffy_t),
    .len        = B.len - sizeof(serialised_spiffy_t)
  @};

  S->alpha      = W->alpha;
  S->beta       = W->beta;
  return N;
@}

static ccstructs_serialisable_I_methods_t const
     spiffy_serialisable_I_methods = @{
  .minimum_size = spiffy_serialisable_I_minimum_size_method,
  .to_block     = spiffy_serialisable_I_to_block_method,
  .from_block   = spiffy_serialisable_I_from_block_method
@};

__attribute__((__always_inline__,__nonnull__(1)))
static inline ccstructs_serialisable_I
spiffy_new_I_serialisable (spiffy_t * S)
@{
  return ccstructs_new_serialisable(ccstructs_core(S),
     &spiffy_serialisable_I_methods);
@}
@end smallexample

@noindent
then we can use the interface as follows:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  spiffy_t   S = @{
    .alpha    = 1,
    .beta     = 2
  @};

  uint8_t     buf[256];
  ccmem_block_t  B = @{
    .ptr      = buf,
    .len      = 256
  @};
  ccmem_block_t  N;
  ccstructs_serialisable_I  IS = spiffy_new_I_serialisable(&S);

  N = ccstructs_serialisable_to_block(L, IS, B);

  ...

  spiffy_t   R;
  ccstructs_serialisable_I  IR = spiffy_new_I_serialisable(&R);

  N = ccstructs_serialisable_from_block(L, IR, B);

  cce_run_body_handlers(L);
@}
@end example

@c page
@node pathname
@chapter The @emph{pathname} interface


The @emph{pathname} interface, represented by the type @objtype{ccstructs_pathname_I}, is meant to
be used as argument to functions that need to operate on @posix{} pathname specifications without
being tied to a specific pathname internal representation; the only requirement is that the pathname
has an external representation as @asciiz{} string.

@menu
* pathname typedefs::           Type definitions.
* pathname api::                Programming interface.
* pathname simple::             Simple implementations.
* pathname examples::           Implementation example.
@end menu

@c page
@node pathname typedefs
@section Type definitions for the @emph{pathname} interface


@deftp {Struct Typedef} ccstructs_pathname_I
Type of the @emph{pathname} interface.  Instances of this type are meant to be handed by value to
function calls.
@end deftp


@deftp {Struct Typedef} ccstructs_pathname_I_methods_t
Type of methods table for the @emph{pathname} interface.  It has the following fields:

@table @code
@item ccstructs_pathname_I_length_fun_t * length
Pointer to function implementing the @method{length} method.

@item ccstructs_pathname_I_pointer_fun_t * pointer
Pointer to function implementing the @method{pointer} method.

@item ccstructs_pathname_I_is_static_fun_t * is_static
Pointer to function implementing the @method{is_static} method.
@end table
@end deftp


@deftypefn {Function Prototype} size_t ccstructs_pathname_I_length_fun_t (cce_destination_t @var{L}, ccstructs_pathname_I @var{I})
Type of functions implementing the @method{length} method.  Return the minimum number of bytes in
the pathname representation as @asciiz{} string, @strong{not} including the terminating zero.  If an
error occurs while generating the external @asciiz{} representation: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefn


@deftypefn {Function Prototype} {char const *} ccstructs_pathname_I_pointer_fun_t (cce_destination_t @var{L}, ccstructs_pathname_I @var{I})
Type of functions implementing the @method{pointer} method.  Return a pointer to an @asciiz{}
representation of the pathname.  For ownership handling: see the @method{is_static} method.  If an
error occurs while generating the external @asciiz{} representation: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefn


@deftypefn {Function Prototype} bool ccstructs_pathname_I_is_static_fun_t (ccstructs_pathname_I @var{I})
Type of functions implementing the @method{is_static} method.  In general, the user of @var{I}
should make a copy of the pathname representation if it needs to keep it independently from the
extent (the lifetime) of @var{I}; but if this function returns @ctrue{}: it can rely on the
existence of the representation for the time it needs it.
@end deftypefn

@c page
@node pathname api
@section Programming interface for the @emph{pathname} interface


@deftypefun ccstructs_pathname_I ccstructs_new_pathname (ccstructs_core_t const * @var{S}, ccstructs_pathname_I_methods_t const * @var{M})
Interface constructor.  Return a new interface @struct{} given a pointer to the source @struct{} and
a pointer to the interface methods.
@end deftypefun


@deftypefun {ccstructs_core_t const *} ccstructs_pathname_self (ccstructs_pathname_I @var{I})
Return a pointer to the @struct{} to which the interface belongs.
@end deftypefun


@deftypefun size_t ccstructs_pathname_length (cce_destination_t @var{L}, ccstructs_pathname_I @var{I})
Apply the method @method{length} to the given argument.  If an error occurs while generating the
external @asciiz{} representation: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun {char const *} ccstructs_pathname_pointer (cce_destination_t @var{L}, ccstructs_pathname_I @var{I})
Apply the method @method{pointer} to the given argument.  If an error occurs while generating the
external @asciiz{} representation: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefun bool ccstructs_pathname_is_static (ccstructs_pathname_I @var{I})
Apply the method @method{is_static} to the given argument.
@end deftypefun

@c page
@node pathname simple
@section Simple implementations of a @emph{pathname} interface


@deftypefun ccstructs_pathname_I ccstructs_new_pathname_from_static_string (const char * @var{ptn})
Build and return a new interface @struct{} for the statically allocated @asciiz{} string referenced
ty @var{ptn}.
@end deftypefun


@deftypefun ccstructs_pathname_I ccstructs_new_pathname_from_dynamic_string (const char * @var{ptn})
Build and return a new interface @struct{} for the dynamically allocated @asciiz{} string referenced
ty @var{ptn}.
@end deftypefun


@deftypefun ccstructs_pathname_I ccstructs_new_pathname_from_static_asciiz (ccmem_asciiz_t const * @var{ptn})
Build and return a new interface @struct{} for the statically allocated @asciiz{} string referenced
ty @var{ptn}.
@end deftypefun


@deftypefun ccstructs_pathname_I ccstructs_new_pathname_from_dynamic_asciiz (ccmem_asciiz_t const * @var{ptn})
Build and return a new interface @struct{} for the dynamically allocated @asciiz{} string referenced
ty @var{ptn}.
@end deftypefun

@c page
@node pathname examples
@section Implementation example for the @emph{pathname} interface.


Here is how we can implement the interface for @objtype{ccmem_asciiz_t} representations:

@smallexample
static size_t
ccstructs_pathname_I_from_asciiz_length (cce_destination_t L,
                                         ccstructs_pathname_I I)
@{
  CCSTRUCTS_PC(ccmem_asciiz_t, S, ccstructs_pathname_self(I));
  return S->len;
@}

static char const *
ccstructs_pathname_I_from_asciiz_pointer (cce_destination_t L,
                                          ccstructs_pathname_I I)
@{
  CCSTRUCTS_PC(ccmem_asciiz_t, S, ccstructs_pathname_self(I));
  return S->ptr;
@}

static bool
ccstructs_pathname_I_from_static_asciiz_is_static (ccstructs_pathname_I I)
@{
  return true;
@}

static bool
ccstructs_pathname_I_from_dynamic_asciiz_is_static (ccstructs_pathname_I I)
@{
  return false;
@}

static ccstructs_pathname_I_methods_t const
    ccstructs_pathname_I_methods_from_static_asciiz = @{
  .length       = ccstructs_pathname_I_from_asciiz_length,
  .pointer      = ccstructs_pathname_I_from_asciiz_pointer,
  .is_static    = ccstructs_pathname_I_from_static_asciiz_is_static
@};

static ccstructs_pathname_I_methods_t const
    ccstructs_pathname_I_methods_from_dynamic_asciiz = @{
  .length       = ccstructs_pathname_I_from_asciiz_length,
  .pointer      = ccstructs_pathname_I_from_asciiz_pointer,
  .is_static    = ccstructs_pathname_I_from_dynamic_asciiz_is_static
@};

ccstructs_pathname_I
ccstructs_new_pathname_from_static_asciiz (ccmem_asciiz_t const * const S)
@{
  ccstructs_pathname_I  I = @{
    .methods    = &ccstructs_pathname_I_methods_from_static_asciiz,
    .self       = ccstructs_core(S)
  @};
  return I;
@}

ccstructs_pathname_I
ccstructs_new_pathname_from_dynamic_asciiz (ccmem_asciiz_t const * const S)
@{
  ccstructs_pathname_I  I = @{
    .methods    = &ccstructs_pathname_I_methods_from_dynamic_asciiz,
    .self       = ccstructs_core(S)
  @};
  return I;
@}
@end smallexample

@c page
@node utils
@chapter Utility definitions


@defmac CCSTRUCTS_PC (@var{POINTER_TYPE}, @var{POINTER_NAME}, @var{EXPRESSION})
Preprocessor macro used to define pointer variables initialised with a cast expression.  It expands
to:

@example
POINTER_TYPE * POINTER_NAME = (POINTER_TYPE *) (EXPRESSION)
@end example

For example, the macro use:

@example
CCSTRUCTS_PC(ccstructs_descriptor_test_failure_t, C, _C);
@end example

@noindent
expands into:

@example
ccstructs_descriptor_test_failure_t * C = \
   (ccstructs_descriptor_test_failure_t *) (_C);
@end example
@end defmac


@defmac CCSTRUCTS_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  If the symbol
@code{__GNUC__} is defined, the expansion is:

@example
__attribute__((__unused__))
@end example

@noindent
otherwise the expansion is the empty string.
@end defmac

@c page
@node ccnames
@appendix Automatically generated @api{} names


The header file @file{ccnames.h} defines a set of macros that generate, at expansion time,
identifiers for functions and variables that have ``well known'' roles in the @api{} of the
CCLibraries projects.

@menu
* ccnames struct common::       Well known functions for @struct{} types.
* ccnames struct table::        Tables of methods for @struct{} types.
* ccnames iface::               Well known names for interface types.
@end menu

@c page
@node ccnames struct common
@appendixsec Well known functions for @struct{} types


@defmac ccname_init (@var{STRUCT_TYPE})
@defmacx ccname_init (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
@api{} function @cfunc{init}.

Functions with this name are constructors for @struct{} instances allocated on the stack or embedded
into enclosing @struct{} instances.  They allocate all the asynchronous resources and initialise the
@struct{} fields.
@end defmac


@defmac ccname_final (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{final}.

Functions with this name are destructors for @struct{} instances allocated on the stack or embedded
into enclosing @struct{} instances.  They release all the asynchronous resources associated to the
@struct{} fields.
@end defmac


@defmac ccname_alloc (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{alloc}.

Functions of this type are memory allocators for @struct{} instances allocated on the heap.  They
might perform the allocation using the @api{} of the library CCMemory.
@end defmac


@defmac ccname_release (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{release}.

Functions of this type are memory releasers for @struct{} instances allocated on the heap.  They
might perform the release using the @api{} of the library CCMemory.
@end defmac


@defmac ccname_new (@var{STRUCT_TYPE})
@defmacx ccname_new (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
@api{} function @cfunc{new}.

Functions with this name are constructors for @struct{} instances allocated on the heap.  The memory
allocation is performed by calling the @cfunc{alloc} function.  The initialisation of the fields is
performed by calling the @cfunc{init} function.
@end defmac


@defmac ccname_delete (@var{STRUCT_TYPE})
Given a @struct{} type name: expand into the name of the @api{} function @cfunc{delete}.

Functions with this name are destructors for @struct{} instances allocated on the heap.  The
finalisation of the fields is performed by calling the @cfunc{final} function.  The memory release
is performed by calling the @cfunc{release} function.
@end defmac


An example of common function implementation for @struct{} types:

@smallexample
#include <ccexceptions.h>
#include <ccmemory.h>
#include <ccnames.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef struct my_coords_t      my_coords_t;

struct my_coords_t @{
  double        X;
  double        Y;
@};

void
ccname_init(my_coords_t, rec) (my_coords_t * S, double X, double Y)
@{
  S->X = X;
  S->Y = Y;
@}

void
ccname_init(my_coords_t, pol) (my_coords_t * S, double RHO, double THETA)
@{
  S->X = RHO * cos(THETA);
  S->Y = RHO * sin(THETA);
@}

void
ccname_final(my_coords_t) (my_coords_t * S)
@{
@}

static my_coords_t *
ccname_alloc(my_coords_t) (cce_destination_t L)
@{
  return (my_coords_t *)ccmem_std_malloc(L, sizeof(my_coords_t));
@}

static void
ccname_release(my_coords_t) (my_coords_t * S)
@{
  ccmem_std_free(S);
@}

my_coords_t *
ccname_new(my_coords_t, rec) (cce_destination_t L, double X, double Y)
@{
  my_coords_t * S = ccname_alloc(my_coords_t)(L);

  ccname_init(my_coords_t, rec)(S, X, Y);
  return S;
@}

my_coords_t *
ccname_new(my_coords_t, pol) (cce_destination_t L, double RHO, double THETA)
@{
  my_coords_t * S = ccname_alloc(my_coords_t)(L);

  ccname_init(my_coords_t, pol)(S, RHO, THETA);
  return S;
@}

void
ccname_delete(my_coords_t) (my_coords_t * S)
@{
  ccname_final(my_coords_t)(S);
  ccname_release(my_coords_t)(S);
@}

int
main (void)
@{
  cce_location_t        L[1];
  my_coords_t *         S;

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    S = ccname_new(my_coords_t, rec)(L, 1.0, 2.0);

    printf("X=%f, Y=%f\n", S->X, S->Y);
    ccname_delete(my_coords_t)(S);
  @}
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@node ccnames struct table
@appendixsec Tables of methods for @struct{} types


@defmac ccname_table_type (@var{STRUCT_TYPE})
@defmacx ccname_table_type (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
methods table type for the @struct{} type.
@end defmac


@defmac ccname_table (@var{STRUCT_TYPE})
@defmacx ccname_table (@var{STRUCT_TYPE}, @var{VARIANT})
Given a @struct{} type name and an optional variant specification: expand into the name of the
methods table for the @struct{} type.
@end defmac


@defmac ccname_method_type (@var{STRUCT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given a @struct{} type name, an optional variant specification, and a method name: expand into the
type name of that variant of the method function for the @struct{} type.
@end defmac


@defmac ccname_method (@var{STRUCT_TYPE}, @var{METHOD_NAME})
@defmacx ccname_method (@var{STRUCT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given a @struct{} type name, an optional variant specification, and a method name: expand into the
name of that variant of the method for that @struct{} type.
@end defmac


An example of methods table implementation for @struct{} types:

@smallexample
#include <ccexceptions.h>
#include <ccnames.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct my_coords_t                      my_coords_t;
typedef struct ccname_table_type(my_coords_t)   ccname_table_type(my_coords_t);

typedef void ccname_method_type(my_coords_t, print) (my_coords_t * S, FILE * stream);

struct my_coords_t @{
  ccname_table_type(my_coords_t) const * methods;
  double        X;
  double        Y;
@};

struct ccname_table_type(my_coords_t) @{
  ccname_method_type(my_coords_t, print) * print_rec;
  ccname_method_type(my_coords_t, print) * print_pol;
@};

static void
ccname_method(my_coords_t, print_rec) (my_coords_t * S, FILE * stream)
@{
  fprintf(stream, "X=%f, Y=%f\n", S->X, S->Y);
@}

static void
ccname_method(my_coords_t, print_pol) (my_coords_t * S, FILE * stream)
@{
  double        RHO   = hypot(S->X, S->Y);
  double        THETA = atan2(S->Y, S->X);

  fprintf(stream, "RHO=%f, THETA=%f\n", RHO, THETA);
@}

static ccname_table_type(my_coords_t) const ccname_table(my_coords_t) = @{
  .print_rec    = ccname_method(my_coords_t, print_rec),
  .print_pol    = ccname_method(my_coords_t, print_pol)
@};

void
ccname_init(my_coords_t, rec) (my_coords_t * S, double X, double Y)
@{
  S->methods = &ccname_table(my_coords_t);
  S->X = X;
  S->Y = Y;
@}

void
ccname_init(my_coords_t, pol) (my_coords_t * S, double RHO, double THETA)
@{
  S->methods = &ccname_table(my_coords_t);
  S->X = RHO * cos(THETA);
  S->Y = RHO * sin(THETA);
@}
@end smallexample

@c page
@node ccnames iface
@appendixsec Well known names for interface types.


@defmac ccname_iface_new (@var{IFACE_TYPE}, @var{STRUCT_TYPE})
@defmacx ccname_iface_new (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT})
Given an interface type name, a struct type name, an optional variant specification: expand into the
name of the @api{} function @cfunc{new} that instantiates that variant of the interface for the
@struct{}.
@end defmac


@defmac ccname_iface_table_type (@var{IFACE_TYPE})
@defmacx ccname_iface_table_type (@var{IFACE_TYPE}, @var{VARIANT})
Given an interface type name and an optional variant specification: expand into the name of the
methods table type for the interface type.
@end defmac


@defmac ccname_iface_table (@var{IFACE_TYPE}, @var{STRUCT_TYPE})
@defmacx ccname_iface_table (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT})
Given an interface type name, a struct type name, and an optional variant specification: expand into
the name of the methods table for that variant of the interface implementation for the @struct{}
type.
@end defmac


@defmac ccname_iface_method_type (@var{IFACE_TYPE}, @var{METHOD_NAME})
@defmacx ccname_iface_method_type (@var{IFACE_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given an interface type name, an optional variant specification, and a method name: expand into the
type name of the method function for that variant of the interface implementation.
@end defmac


@defmac ccname_iface_method (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{METHOD_NAME})
@defmacx ccname_iface_method (@var{IFACE_TYPE}, @var{STRUCT_TYPE}, @var{VARIANT}, @var{METHOD_NAME})
Given an interface type name, a struct type name, an optional variant specification, and a method
name: expand into the name of the method function for that variant of the interface implementation
for the struct type.
@end defmac


Let's say we have this @struct{} definition:

@smallexample
typedef struct my_coords_t      my_coords_t;

struct my_coords_t @{
  double        X;
  double        Y;
@};
@end smallexample

@noindent
and we want to define an interface type @objtype{my_printable_I} to print the @struct{} on a
standard stream, both in rectangular and polar forms.

Every interface must have a @struct{} acting as table of pointers to functions, whose functions
implements the interface methods.  The interface @struct{} type is unique, the methods table
@struct{} type is unique; for every data @struct{} that implements the interface: we need a methods
table and an interface constructor.

The interface @struct{} type and the methods table @struct{} type are defined as follows:

@smallexample
typedef struct my_printable_I   my_printable_I;
typedef struct ccname_iface_table_type(my_printable_I) \
  ccname_iface_table_type(my_printable_I);

struct my_printable_I @{
  ccname_iface_table_type(my_printable_I)  const * methods;
  ccstructs_core_t                         const * self;
@};

typedef void ccname_iface_method_type(my_printable_I, print) \
  (my_printable_I I, FILE * stream);

struct ccname_iface_table_type(my_printable_I) @{
  ccname_iface_method_type(my_printable_I, print) * print_rec;
  ccname_iface_method_type(my_printable_I, print) * print_pol;
@};
@end smallexample

The @objtype{my_printable_I} interface @api{} is defined as follows:

@smallexample
my_printable_I
my_printable_new (ccstructs_core_t const * S,
                  ccname_iface_table_type(my_printable_I) const * M)
@{
  my_printable_I        I = @{
    .methods    = M,
    .self       = S
  @};
  return I;
@}

ccstructs_core_t const *
my_printable_self (my_printable_I I)
@{
  return I.self;
@}

void
my_printable_print_rec (my_printable_I I, FILE * stream)
@{
  I.methods->print_rec(I, stream);
@}

void
my_printable_print_pol (my_printable_I I, FILE * stream)
@{
  I.methods->print_pol(I, stream);
@}
@end smallexample

The implementation of @objtype{my_printable_I} for the data @struct{} @objtype{my_coords_t} is
defined as follows:

@smallexample
static void
ccname_iface_method(my_printable_I, my_coords_t, print_rec) (my_printable_I I, FILE * stream)
@{
  CCSTRUCTS_PC(my_coords_t, S, my_printable_self(I));

  fprintf(stream, "X=%f, Y=%f\n", S->X, S->Y);
@}

static void
ccname_iface_method(my_printable_I, my_coords_t, print_pol) (my_printable_I I, FILE * stream)
@{
  CCSTRUCTS_PC(my_coords_t, S, my_printable_self(I));
  double        RHO   = hypot(S->X, S->Y);
  double        THETA = atan2(S->Y, S->X);

  fprintf(stream, "RHO=%f, THETA=%f\n", RHO, THETA);
@}

static ccname_iface_table_type(my_printable_I) const ccname_iface_table(my_printable_I, my_coords_t) = @{
  .print_rec    = ccname_iface_method(my_printable_I, my_coords_t, print_rec),
  .print_pol    = ccname_iface_method(my_printable_I, my_coords_t, print_pol)
@};

my_printable_I
ccname_iface_new(my_printable_I, my_coords_t) (my_coords_t * S)
@{
  return my_printable_new(ccstructs_core(S), &ccname_iface_table(my_printable_I, my_coords_t));
@}
@end smallexample

We can use the interface as follows:

@smallexample
int
main (void)
@{
  cce_location_t        L[1];
  my_coords_t *         S;
  my_printable_I        I;

  if (cce_location(L)) @{
    cce_run_catch_handlers_final(L);
  @} else @{
    S = ccname_new(my_coords_t, rec)(L, 1.0, 2.0);
    I = ccname_iface_new(my_printable_I, my_coords_t)(S);

    my_printable_print_rec(I, stdout);
    my_printable_print_pol(I, stdout);
    ccname_delete(my_coords_t)(S);
  @}
  exit(EXIT_SUCCESS);
@}
@end smallexample

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
the package CCExceptions is available at:

@center @url{https://github.com/marcomaggi/ccexceptions/}

@noindent
the package CCMemory is available at:

@center @url{https://github.com/marcomaggi/ccmemory/}

@noindent
the package CCTests is available at:

@center @url{https://github.com/marcomaggi/cctests/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

